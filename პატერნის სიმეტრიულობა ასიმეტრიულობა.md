**პატერნი სიმეტრიულია, მაგრამ იმპლემენტაცია — ასიმეტრიული.**  
პატერნი ამბობს:  
_„დადე API ყველგან და გამოყავი შიდა და გარე მხარე, მიუხედავად იმისა, არის თუ არა ეს ინტერფეისი შესატანი თუ გამტანი, ძირითადი (primary) თუ მეორეული (secondary).“_  
აი ეს არის **სიმეტრიული** ნაწილი.

პატერნები, როგორიცაა Model-View-Controller და მისი მსგავსი, მხოლოდ _მმართავ მხარეს_ არეგულირებენ. შესაძლებელია, ისინი სწორად იყოს იმპლემენტირებული და მაინც არსებობდეს მჭიდრო კავშირი ბიზნეს ლოგიკასა და ბაზას ან სხვა მეორეულ აქტორებს შორის.

**Ports & Adapters** განსხვავდება იმით, რომ ამბობს:  
_აპლიკაციას არ უნდა ჰქონდეს ცოდნა იმაზე, რისგან შედგება გარე კავშირები, მიუხედავად იმისა, მართავენ ისინი მას (driving) თუ მასზე არიან დამოკიდებული (driven)._  
აპლიკაციიდან გარე აქტორებზე **არ უნდა იყოს კომპილაციისდროინდელი დამოკიდებულებები (compile-time dependencies)** — **არც ერთ მხარეს**.

მაგრამ როცა იწყება პატერნის იმპლემენტაცია, ჩნდება მარცხნივ-მარჯვნივ ასიმეტრია:

- მართავმა (driving) აქტორებმა _უნდა იცოდნენ აპის შესახებ_, რომ გამოიძახონ იგი.
    
- აპლიკაციას კი _უნდა იცოდეს მეორეული (driven) აქტორები_, რათა მათ გამოიძახოს.
    

მიუხედავად იმისა, რომ აპლიკაცია არ იცნობს მართავ აქტორებს, **კონფიგურატორმა** მაინც უნდა გადასცეს მას მეორეული აქტორები driven პორტებისთვის.  
ეს ქმნის კოდში **ასიმეტრიას**, კერძოდ:

- **Driving პორტებზე** ვქმნით _მიწოდებულ (provided)_ ინტერფეისებს,
    
- **Driven პორტებზე** კი — _მოთხოვნილ (required)_ ინტერფეისებს.
    

ამგვარად, **პატერნი თავად სიმეტრიულია**, ხოლო **იმპლემენტაცია ასიმეტრიულია.**