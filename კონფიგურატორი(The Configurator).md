
ვიღაცამ ხომ უნდა დააკავშიროს ყველა ეს ნაწილი?  
უნდა არსებობდეს კოდის ელემენტი, რომელიც:

- მმართავ აქტორებს (driving actors) ეტყვის, როგორ დაუკავშირდნენ აპს,
    
- აპს კი მიანიშნებს, რომელი **მართული აქტორები** (driven actors) გამოიყენოს.
    
აი ეს არის **კონფიგურატორის როლი**.


იმისათვის, რომ კონფიგურატორმა თავისი სამუშაო შეასრულოს, მას უნდა იცოდეს ყველა მოთამაშე:

- აპი,
    
- მმართავი აქტორები (ან მათი ადაპტერები),
    
- მართული აქტორები (ან მათი ადაპტერები).
    

**პატერნი არ განსაზღვრავს** კონფიგურატორის არქიტექტურას  
ის, თუ როგორ შექმნი მას, დამოკიდებულია შენს საჭიროებებსა და ტექნოლოგიაზე.  
მაგრამ არ აქვს მნიშვნელობა როგორ დაალაგებ, **სავალდებულოა, რომ შემდეგი მოქმედებები შესრულდეს**:


1. **შექმენი თითოეული მართული ინტერაქტორი**  
    (ანუ მართული ადაპტერი ან ისეთი აქტორი, რომელსაც ადაპტერი არ სჭირდება).
    
2. **შექმენი აპი.**
    
3. **მიაწოდე აპს ეს მართული ინტერაქტორები.**
    
4. **შექმენი თითოეული მმართავი ინტერაქტორი** (აქტორი ან ადაპტერი)  
    და მიაწოდე მას აპი, რომლის გამოყენებაც უნდა.

![[Pasted image 20250706135521.png]]

#### როგორ შეიძლება აპმა გაიგოს, რომელი მართული აქტორი გამოიყენოს?

ამის სამი ძირითადი გზა არსებობს:

1. **კონსტრუქტორის გზით**  
    — კონფიგურატორი აპის კონსტრუქტორში აწოდებს მართულ აქტორებს.
    
2. **სეტის ფუნქციის გზით (Setter Method)**  
    — აპი თავის ინტერფეისში ასრულებს ფუნქციას, რომელიც აძლევს საშუალებას მართული აქტორი მოგვიანებით მიენიჭოს.  
    ასეთ დროს მმართავი აქტორი იძახებს ამ ფუნქციას.
    
3. **სერვის ლოკატორის გამოყენებით**  
    — აპი თავად ეძებს საჭირო ობიექტს, სერვის ლოკატორის მეშვეობით.

თუ იყენებ **დამოკიდებულებების ინექციის (DI) ჩარჩოს**, როგორიცაა **Spring**,  
პირველი ორი მიდგომა — კონსტრუქტორით ან სეტერით მიწოდება — სრულიად ბუნებრივია მისთვის.


როგორც წესი, პროგრამის **`main()` ფუნქცია** ან ე.წ. **composition root** ასრულებს კონფიგურატორის როლს  
და აერთიანებს ყველა მონაწილეს.