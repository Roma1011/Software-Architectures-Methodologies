## **უფრო გრძელი ისტორია**

ერთი ბოლო წვლილი, რაც ხუანმა ამ წიგნში შეიტანა, იყო ის, რომ დაბრუნდა და თაიმლაინი გაასუფთავა. მადლიერი ვარ მისი დეტალებზე ორიენტირებულობისა და სიზუსტისთვის.

ერთ საკითხზე მკაფიოდ მინდა ვიყო: **მე არ ვარ სისტემური პროგრამისტი**, ყოველთვის ვიყავი **აპლიკაციის პროგრამისტი**. მაგრამ გავიზარდე Smalltalk-ის **Model-View-Controller** არქიტექტურით მართვის მხარეს, სადაც დრაივერების მარტივად შეცვლა შეიძლებოდა. მე უბრალოდ ვვარაუდობდი და ველოდი, რომ იგივე უნდა ყოფილიყო შესაძლებელი მოწოდების (driven) მხარესაც. სისტემის არქიტექტორებს ვთხოვდი ამ შესაძლებლობას და მათგან ვიღებდი პასუხს, რომ ეს შეუძლებელი იყო.

დაცვის მიზნით დავიწყე კითხვების დასმა საკუთარი თავისთვის:  
**"როგორ უნდა იყოს მოწყობილი ყველაფერი ისე, რომ ეს შესაძლებელი გახდეს?"**  
თავდაპირველად ამას "shunt" ვუწოდე, შემდეგ "loopback" (მაშინ **mock**-ები ჯერ არ არსებობდა), მოვიფიქრე იდეა როგორ შეიძლებოდა ამის გაკეთება და საბოლოოდ 2004-2005 წლებში მქონდა შესაძლებლობა დამეწერა კოდი, რომელიც ამას აკეთებდა.

სხვა სიტყვებით რომ ვთქვათ, **ამ არქიტექტურა შევქმენი მე, როგორც აპლიკაციის პროგრამისტმა**, რათა მქონოდა უსაფრთხოების / ჩანაცვლების ფუნქციონალი, რაც მჭირდებოდა აპლიკაციის განვითარებისთვის.


## **1988: Smalltalk და C**

ალისტერმა გაუცნობიერებლად დააინსტალირა Model-View-Controller თავისი Smalltalk პროტოტიპში, მაგრამ მისმა C პროგრამისტმა არა. როდესაც გაჩნდა საჭიროება, რომ წყარო შეცვლილიყო, პროგრამა მთლიანად უნდა დაეშალა და თავიდან დაეწერა.

IBM-ის კვლევით ცენტრში, შვეიცარიაში, ახლახან ვისწავლე Smalltalk ახალი პროექტისთვის. მყავდა ერთი პრედოქტორანტი სტუდენტი, რომელიც ჩემს Smalltalk პროტოტიპს გადაიტანდა სწორად და სწრაფად მომუშავე დიაგრამის რედაქტორში, ენით  C.

Smalltalk-ის ტუტორიალში პირველი დავალება იყო "მოლაპარაკე თუთიყუში", რათა გვეხმარა მდგომარეობის მანქანებთან (state machines) მუშაობის სწავლაში. როგორც აღმოჩნდა (და მე მაშინ არ ვიცოდი), ეს მაგალითი იყენებდა **Model-View-Controller** არქიტექტურას.

როცა პირველ რეალურ პროგრამას ვწერდი, უბრალოდ დავაკოპირე ეს მაგალითი და მოვარგე ჩემს საჭიროებას. (აქ ცალკე გაკვეთილიც კი შეიძლება მივიღოთ იმაზე, როგორ ვისწავლოთ ახალი ენა, მაგრამ ახლა ამას არ შევეხოთ.)

შედეგად, ჩემს კოდში მქონდა MVC სტრუქტურა  ისე, რომ არც ვიცოდი ეს.

ჩემი პრედოქტორანტი, ცხადია, ამ პატერნს არ იცნობდა (მართალი რომ ვთქვათ, არც მე). ის პროგრამირებდა C-ში.

მისი პროგრამა იყო გრაფიკული რედაქტორი, რომელიც ქსელზე კომპიუტერებს შორის გაგზავნილი შეტყობინებების თანმიმდევრობას ასახავდა ვიზუალურად.

ჩვენ წარმოგვედგინა, რომ დიაგრამაზე იქნებოდა 10-30 შეტყობინება, რადგან ისინი ხელით უნდა დახაზულიყო. თუმცა ჩვენი პირველი კლიენტი ძალიან აღფრთოვანდა  დაინახა როგორ შეიძლებოდა ამ რედაქტორის გამოყენება, რათა შეეხედა დიდ ქსელურ ლოგებს, სადაც სადღაც შეცდომა იყო.

პირველივე შემთხვევამ გამოიყენა დაახლოებით **120 სერვერის სადგური ჰორიზონტალურად და ათასობით შეტყობინება**.

ეს, ბუნებრივია, **გააფუჭა** მისი პროგრამა. ის **მყარად იყო მიბმული გრაფიკულ ინტერფეისზე**, კლავიატურაზე და მაუსზე, და არ შეეძლო არც ქსელიდან, არც ფაილიდან მონაცემის მიღება.

ჩემს Smalltalk პროგრამას რომ დავხედე, ვუთხარი:  
**"უბრალოდ ისე გააკეთე, რომ მონაცემი ქსელიდან მოვიდეს და არა კლავიატურიდან"**  ეს MVC-ის სტანდარტული მიდგომაა.

მან უცნაურად შემომხედა და მითხრა, რომ ასე ვერ გააკეთებდა, თავიდან უნდა დაეწყო.

დავიბენი. **რატომ არ შეეძლო უბრალოდ წყაროს შეცვლა?**

წლების შემდეგ გავიაზრე: MVC არქიტექტურამ მაიძულა, რომ შემექმნა ინტერფეისი ყველა შეყვანისთვის.  
ამის შედეგად, შემეძლო შემეცვალა შეყვანის წყარო ნებისმიერ დროს  ტესტები, UI, ქსელიდან შეტყობინება  ყველაფერი შესაძლებელი იყო.

**ამ გამოცდილებამ მასწავლა, რამდენად მნიშვნელოვანია აპლიკაცია გარს აკრაოს ინტერფეისებით.**



### 1994: Smalltalk და რელაციური მონაცემთა ბაზები

ფიქსირებულ ფასზე და ფიქსირებულ დროზე შეთანხმებულ პროექტში, რომელიც მოიცავდა ობიექტურ-რელაციურ მაპერს, ინფრასტრუქტურის დიზაინერებმა დაასკვნეს, რომ მათ უნდა შეეცვალათ თავიანთი დიზაინი SQL ბაზაზე მუშაობის გაუმჯობესების მიზნით. იმის გამო, რომ აპლიკაციის პროგრამისტებისთვის არ შეეძლოთ ინტერფეისით ეწარმოებინათ მეხსიერებაში არსებული ტესტური ბაზა, მათ რამდენიმე კვირით შეაჩერეს პროექტი და სასწრაფოდ გადაწერეს მაპერი.

**ალისტერმა პირველად დახატა ექვსკუთხა ფორმა** — მის სლაიდებში, ობიექტზე ორიენტირებული პროგრამირების კურსის დროს.

გადამწყვეტი მოვლენა, რომელმაც საბოლოოდ მიმიყვანა _Ports & Adapters_ არქიტექტურის აღმოჩენამდე, იყო ერთ-ერთი პროექტი 1994-95 წლებში, რომელსაც ჰქონდა Smalltalk-ით დაწერილი ფრონტ-ენდი და დაკავშირებული იყო რელაციურ მონაცემთა ბაზასთან.

ობიექტის-რელაციური მაპერის პირველი იმპლემენტაცია იყო ძალიან კოდზე დამოკიდებული და ნელი. ინფრასტრუქტურის გუნდმა გადაწყვიტა, რომ მთლიანი მაპერი თავიდან უნდა დაეწერათ. ამისთვის რამდენიმე კვირა დასჭირდათ.

მე ვთხოვე ინფრასტრუქტურის გუნდს, უბრალოდ მოეცათ ჩვენთვის API და ჩვენ დავმოკლებდით უკანა მხარეს, გამოვიყენებდით _loopback_-ებს მცირე ტესტების შესაქმნელად, სანამ აპლიკაციას დავწერდით.

**(ყველაზე ადრეული ექვსკუთხა ნახაზი, 1994 წ.)**
![[Pasted image 20250711011808.png]]

მათ მითხრეს იგივე, რაც ჩემმა C პროგრამისტმა 6 წლის წინ:  
**„ეს შეუძლებელია, არ ვიცი, რაზე საუბრობ.“**  
მათ შეაჩერეს ფუნქციონალის განვითარება რამდენიმე კვირით, სანამ მონაცემთა ბაზის ინტერფეისს თავიდან წერდნენ.

**თუკი მათ მოექციათ უკანა მხარე „საჭირო ინტერფეისით“ (required interface), ყველა შეგვეძლო გაგრძელება.**  
მაშინ არ მქონდა სიტყვები, რომ ამეხსნა, რა მინდოდა ან როგორ უნდა გაგვეკეთებინა. უბრალოდ ვიცოდი, რომ ეს შესაძლებელი იყო და ეს იყო სწორი დიზაინის გზა.

იმ პროექტის მიმდინარეობისას, გუნდს ვასწავლე ერთკვირიანი კურსი „დიზაინი ობიექტურ ტექნოლოგიაში“ (ახლა უკვე წიგნია). მას უკვე ჰქონდა ექვსკუთხა ფორმა  და ძირითადი კონცეფციაც ჩამოყალიბებული იყო, თუმცა ჯერ კიდევ არ ვიცოდი, რა ნიშნავდა თითოეული მხარე. ვიცოდი, რომ ისინი უნდა არსებულიყო, უნდა ყოფილიყო API-ები, მაგრამ მეტის თქმა არ შემეძლო.


### 2000: მჰოს ამინდის სისტემა

**ალისტერმა მოინახულა მეგობარი, რომელსაც აპლიკაციის უამრავ ვარიანტთან და წყაროსთან ჰქონდა პრობლემები. პრობლემა გადაჭრეს სწორედ ამ არქიტექტურით.**

დაახლოებით 2000 წელს ვესტუმრე ჩემს მეგობარს — **მჰო სალიმს**, რომელიც მითხრა, რაზე მუშაობდა და რა პრობლემას ებრძოდა.

მისი ამინდის გაფრთხილების სისტემა იღებდა ამინდის მონაცემებს _NOAA_-დან და სხვა წყაროებიდან და მომხმარებელთა ბაზის დახმარებით (სადაც ტელეფონის ნომრები ინახებოდა), ურეკავდა მათ და ტოვებდა ხმოვან შეტყობინებას, როდესაც რაიმე ამინდის გაფრთხილება მათ ეხებოდა. (ეს იყო 1990-იანების ბოლო.)

**პრობლემა ის იყო, რომ ინტერნეტი იდგამდა ფეხს** და მას უწევდა ცალკე, სპეციალიზებული სისტემების წერა ყოველი ტექნოლოგიური ვარიანტისთვის. მონაცემები შემოდიოდა პირდაპირი არხებით, RSS-ით, ინტერნეტით. გამოსავალი იყო: ანალოგურ ტელეფონებზე ხმოვანი შეტყობინებები, ტექსტური პეიჯერები, RSS არხები და ინტერნეტიც უკვე თავს იჩენდა. ამასთან ერთად, უკვე იწყებოდა მეორე აპლიკაციის შექმნა, რომელიც უშუალოდ დაკავშირებული უნდა ყოფილიყო ამ სისტემასთან.

**ტექნოლოგიური ვარიანტებისა და მათი კომბინაციების რაოდენობამ ისე დააბნია, რომ უიმედო გახდა სისტემის შემდგომი მოვლის და განვითარებისთვის.**

მე კი, API-ებზე გაზრდილი, ვერ ვხედავდი პრობლემას. დაფაზე დავუხატე რაღაც მსგავსი ნახატი .

**მაშინ ჯერ კიდევ არ მქონდა სიტყვები თითოეული ელემენტის დასახელებისთვის.** უბრალოდ ვიცოდი, როგორც ერთმა კოლეგამ თქვა:  
**„მომეცი API ან მომეცი სიკვდილი!“**  
(ალუზია ამერიკის რევოლუციური ომის ცნობილ ფრაზაზე.)

მჰომ კი უცნაურად შემომხედა. მისთვის ეს აშკარად სრულიად ახალი აზროვნება იყო.

**ამ საუბრის შემდეგ, უფრო სერიოზულად დავიწყე მუშაობა იმაზე, რომ გამერკვია  რა იყო ის, რასაც უკვე წლებია ველოდი, რომ სხვებიც ასე გააკეთებდნენ.**

**მჰოს ამინდის სისტემა ექვსკუთხაში**
![[Pasted image 20250711012005.png]]

---

### 2003: პირველი გამოქვეყნება Ward Cunningham-ის wiki-ში

**ალისტერმა გამოაქვეყნა სტატია სახელწოდებით “Hexagonal Architecture” Ward Cunningham-ის “Wiki Wiki Web”-ში.**  
🔗 ბმული არქივში: https://web.archive.org/web/20030320101333/http://www.c2.com/cgi/wiki?HexagonalArchitecture

---

### 2005: Ports & Adapters

**2005 წლის 4 სექტემბერი:**  
ალისტერმა ფორმალურად აღწერა ეს პატერნი GoF (Gang of Four) სტილში და მისცა მას სწორი სახელი: **“Ports & Adapters.”**  
სტატია გამოაქვეყნა საკუთარ ვებსაიტზე 5 სექტემბერს და გააგზავნა RSS-განცხადება თემაზე  _რა_ და _რატომ_.

ალისტერმა ასევე დაამატა სტატია Ward-ის wiki-ში:  
🔗 http://wiki.c2.com/?PortsAndAdaptersArchitecture

**2005 წელს, საბოლოოდ ვიპოვე დიზაინის პატერნების ნაკრები, რომელიც დაემთხვა ჩემს წარმოდგენას.** ერთ-ერთი მათგანი იყო _Pedestal_, რომელიც მშვენივრად უხდებოდა კლასიკურ _Adapter_ პატერნს, როგორც აღწერილია Design Patterns წიგნში.

**დაბოლოს გავიგე (9 წლის შემდეგ!), რომ hexagon-ის “ფასეტები” იყო სწორედ “პორტები”, რომლითაც სისტემა ესაუბრება გარე სამყაროს.**  
თითოეული პორტი წარმოადგენს API-ს, რომელიც განსაზღვრავს კონკრეტულ კომუნიკაციას გარე აგენტთან ან აქტორთან.


### აი ჩემი ჩანაწერი RSS-Feed-ში, 2005 წლის 15 ივლისს:

---
title: Ports and Adapters Architecture (formerly "Hexagonal" architecture)
date: 2005-07-15T13:01:00-0700
tags: [architecture, hexagonal, ports-and-adapters, history, rss]
link: http://c2.com/cgi/wiki?PortsAndAdaptersArchitecture
---

    სადღაც 1990-იანების შუაში დავიწყე სიმეტრიული არქიტექტურის ხატვა, სადაც მონაცემთა ბაზა განიხილება არა როგორც "სტეკის ბოლოში" მყოფი ელემენტი, არამედ სრულად აპლიკაციის გარეთ — ზუსტად ისე, როგორც მომხმარებლის ინტერფეისთან ვიქცევით.
    
    იმისთვის, რომ დამენგრია წარმოდგენა ზემოთ/ქვემოთ და მარცხნივ/მარჯვნივ მდებარე ფენებზე, შევქმენი ექვსკუთხა ფორმა და დავარქვი არცთუ შთამბეჭდავი სახელი — *HexagonalArchitecture*. უბრალოდ იმიტომ, რომ მაშინ ჯერ არ ვიცოდი, რა ნიშნავდა ეს "hexagon", მაგრამ ვიცოდი, რომ უნდა ჰქონოდა ფესვები (facets), და 5-ზე ნაკლები კუთხიანი ფიგურები ვიზუალურად არ მოუხდებოდა (თანაც პენტაგონი უფრო ძნელად სახატავია).
    
    საბოლოოდ გავიგე, რას ნიშნავდა ეს ნახატი და მივხვდი, რომ არქიტექტურის ეს სურათი უნდა გვეთქვა **Ports and Adapters** — წარმოიდგინეთ საოპერაციო სისტემის პორტები, ან Hi-Fi მოწყობილობის პორტები, და Design Pattern-ში აღწერილი "Adapter" პატერნი.

    ერთ დღეს აუცილებლად დავწერ სრულ სტატიას, როდესაც მეტი მაგალითი და პროექტული გამოცდილება მექნება, მაგრამ მანამდე უბრალოდ ვათავსებ Ward-ის wiki-ზე. თუ იცით რაიმე წინამორბედი ან მსგავსი არქიტექტურული პატერნი, დამიკავშირდით.




---

### 2005 წლის სექტემბერში დავწერე სტატია, რომელიც პატერნს აღწერდა:

**"Ports & Adapters", ასევე ცნობილი როგორც "Hexagonal Architecture."**

- “Hexagonal Architecture” უფრო მარტივად სათქმელი და დამამახსოვრებელია, ამიტომ ის მეტსახელად დარჩება.
    
- ამ წიგნში ამ ორ ტერმინს ერთმანეთის ნაცვლად ვიყენებთ.
    
- სახელწოდება _Ports & Adapters_ გამოვიყენებთ მაშინ, როცა პატერნის ბირთვულ კონცეფციებს  პორტებსა და ადაპტერებს  განსაკუთრებული ყურადღება უნდა მივაქციოთ.
    

**სტატია სრულად გამოქვეყნებულია აქ:**  
📎 [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)

---

### 2017: ხუანის აღმოჩენა

ხუანმა დაწერა, რომ 2017 წელს:

> „ვამზადებდი საშუალო ზომის აპლიკაციას. ერთ დღეს, როცა ლეპტოპის ეკრანს ვუყურებდი, მივხვდი, რომ სავსე იყო ფრეიმვორქის კოდით და საერთოდ ვერ ვიგებდი, რა ხდებოდა ბიზნესის ლოგიკის დონეზე. იმ მომენტიდან დავიწყე ინტერნეტში ძებნა და აღმოვაჩინე არქიტექტურა, რომელიც აბრკოლებს ბიზნეს ლოგიკის მიბმას ფრეიმვორქებზე. შემდეგ გავიგე DDD-ზეც.“

და აგრძელებს:

> „ამ არქიტექტურებიდან ყველაზე მეტად _Hexagonal Architecture_ მომწონს, რადგან პორტებისა და ადაპტერების მექანიზმი უფრო მოქნილია კომუნიკაციისთვის. ასე აღმოვაჩინე HA. მას შემდეგ დღემდე (და იმედია მომავალშიც), არ შევწყვეტ მის შესახებ კითხვასა და სწავლას.“

---

### 2017: პარიზის ლექცია

- ალისტერმა ჩაატარა თავისი პირველი საჯარო პრეზენტაცია ამ პატერნზე პარიზში.
    
- ლაივ პროგრამისტად იყო **Thomas Pierrain**, რომელიც კოდის მაგალითს ადგილზე წერდა.
    
- ალისტერმა პირველად დაასახელა „driving“ და „driven“ მხარეები და პორტებს მისცა ფორმატური დასახელება: _“for doing something”_.
    

**მთავარი დასკვნა:**  
პატერნი ფართოდ უგულებელყოფილი იყო მანამ, სანამ Domain-Driven Design (DDD) საზოგადოებამ არ დაიწყო მისი გამოყენება. ამის შემდეგ ბევრმა დაიწყო მის შესახებ ლექციების და ტუტორიალების ჩატარება  ხშირად არასწორად.

2015 წელს ალისტერმა თავად მოითხოვა საუბრის შესაძლებლობა, რომ პატერნის ისტორია და მიზნები განემარტა.

📽 ვიდეოები:

- [🎬 Flipchart talk: Alistair](https://www.youtube.com/watch?v=th4AgBcrEHA)
    
- [🎬 Coding: Thomas, Part 1](https://www.youtube.com/watch?v=iALcE8BPs94)
    
- [🎬 Coding: Thomas, Part 2](https://www.youtube.com/watch?v=DAe0Bmcyt-4)
    

---

### 2018: პირველი ესპანური თარგმანი

- 2018 წლის 24 ივნისს ხუან მანუელ გარიდო დე პასმა თარგმნა და გამოაქვეყნა ესპანურად:
    

📎 [https://jmgarridopaz.github.io/content/arquitecturahexagonal.html](https://jmgarridopaz.github.io/content/arquitecturahexagonal.html)

---

### 2021: დარედაქტირდა ორაზროვანი წინადადება

- 2021 წლის 9 ოქტომბერს ალისტერმა და ხუანმა ერთად გადახედეს სტატიას.
    
- მათ გადააწერეს ერთ-ერთი წინადადება, რომელიც შეცდომით ან გაუგებრად წარმოადგენდა ადაპტერებსა და პორტებს _driving_ მხარეს.
    

> ალისტერი აღნიშნავს:  
> „ეს აჩვენებს, რამდენად მოწადინებული იყო ხუანი სიზუსტის მიღწევაში. ვფიქრობ, სასწაულია, რომ წლების განმავლობაში ეს ერთადერთი შეცდომა აღმოჩნდა.“

---

### 2022: Component + Strategy

- ალისტერმა საბოლოოდ აღმოაჩინა UML-ის ელემენტები: **Component** და **Required Interface**, რომლებზე ხუანს წლების წინ მიუთითებია.
    
- ამით პატერნი “Ports & Adapters” იქცა **Component + Strategy** პატერნის სპეციფიკურ შემთხვევად.
    

> "Hexagon" = UML-ის კომპონენტი.  
> კომპონენტი უნდა ჰქონდეს ზუსტად განსაზღვრული API-ები ყველა მხარეს. სწორედ ამას მოითხოვს Hexagonal Architecture.

მაგრამ:

> **Hexagonal Architecture**-ის სწორად მუშაობისთვის საჭირო გახდა “driven actor”-ების _Strategy_-ებად გადაცემა — რაც UML-ის _Component_ პატერნს თავისთავად არ მოეთხოვება.

- ამ ყველაფერზე ალისტერმა დაწერა სტატია:
    

📎 Component + Strategy generalizes Ports & Adapters

---

### 2023: Configurable Receiver

- ალისტერმა და ხუანმა განიხილეს _dependency injection_-ის და _configurable dependency_-ის პრობლემები.
    
- **Dan North**-მა შესთავაზა ახალი სახელი: **Configurable Receiver**.
    
- ისინი დათანხმდნენ და ეს ტერმინი დაამკვიდრეს.
    

> დაახლოებით 2010 წელს Gerard Meszaros-მა დამეხმარა სახელის მიგნებაში: _Configurable Dependency_.  
> მაგრამ ეს არასდროს ამოვწერე სრულფასოვან სტატიად.

- საბოლოოდ 2023 წლის მაისში დაიწერა სრული სტატია:
    

📎 https://alistaircockburn.com/Articles/Configurable-Receiver