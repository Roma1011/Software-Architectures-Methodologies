**მიმღების გაწერა ან შეცვლა გაშვების დროს.**

მიმღების გაწერა გაშვების დროს გავლენას ახდენს როგორც **სორს კოდის სტრუქტურაზე**, ასევე **გაშვების დროის ქცევაზე**. ეს ნიმუში ორივეს ეხება.

**Configurable Receiver მოიცავს** როგორც **Dependency Injection**, ასევე **Dependency Lookup**-ს.

არ აქვს მნიშვნელობა ვსაუბრობთ თუ არა ფუნქციებზე, ობიექტებზე თუ სისტემებზე — **გამგზავნს სჭირდება მიმღების გამოძახება ან შეტყობინების გაგზავნა**.  
ზოგჯერ გვინდა, რომ მიმღები გაშვების დროს განვსაზღვროთ.

მაგალითად:

- სისტემის შემუშავება **სატესტო მონაცემებით**, შემდეგ კი მისი გაშვება **პროდუქციულ მონაცემებზე** ისე, რომ სორს კოდი არ შევცვალოთ — მხოლოდ ხელახლა დავიწყოთ სისტემა და ინიციალიზაციისას დავაყენოთ სასურველი მონაცემთა მომწოდებელი.
    
- სისტემის განვითარება: მაგალითად, საწყის ეტაპზე მონაცემთა ფაილების გამოყენება და დროთა განმავლობაში სხვადასხვა მონაცემთა ბაზებზე გადასვლა.
    
- მიმღებების შეცვლა **რეალურ დროში**, მიღებული მონაცემების მიხედვით.
    

იმისთვის, რომ მიმღები გაშვების დროს კონფიგურირებადი იყოს, საჭიროა დავამატოთ **Configurator** 
Configurator-ის კონკრეტული დიზაინი ამ ნიმუშის ფარგლებს გარეთაა, როგორც შემდგომში განვიხილავთ.

![[Pasted image 20250801235625.png]]
Configurable Receiver informალური ხედი, რომელიც აჩვენებს configurator-ის განთავსების ორ არჩევანს.


### When to use the pattern

ეს ნიმუში **გართულებას ცვლის მოქნილობაში**. აქ წარმოდგენილია ეს გაცვლა ოთხი პრიზმიდან:

- **Indications**
    
- **Counterindications**
    
- **Complicating side effects**
    
- **Overdose effect** (იდეა, რომ კარგის ზედმეტი რაოდენობაც ცუდია).
    

#### Indications

- გსურთ მიმღების გაწერა გაშვების დროს — იქნება ეს:
    
    - ინიციალიზაციისას,
        
    - რეალურ დროში თითოეული მონაცემისთვის,
        
    - თუ წლების განმავლობაში ტექნოლოგიების ცვლილებისას.
        
- გსურთ **პროდუქციული კავშირების ჩანაცვლება სატესტო harness-ებით** და პირიქით — ისე, რომ გამგზავნის სორს კოდი არ შეცვალოთ.
    
- ნებისმიერ შემთხვევაში, გსურთ თავიდან აიცილოთ სორს კოდის ცვლილება და სისტემის ხელახლა აგება ყოველ ჯერზე, როცა ამ ცვლილებებს აკეთებთ.
    

#### Counterindications

- არ ელით ამგვარ საჭიროებებს და არ გსურთ სისტემაში ზედმეტი სირთულის შეტანა.
    
- ყველა შეტყობინების მიმღები საჭირო არ არის იყოს კონფიგურირებადი, ამიტომ **არჩევით უნდა გადაწყვიტოთ**, სად გამოიყენოთ ეს ნიმუში.

## შემაწუხებელი გვერდითი ეფექტები (Complicating Side Effects):

- ვინაიდან გამოძახება განისაზღვრება შესრულების დროს, ეს ზრდის კიდევ ერთ საფეხურს ინდირექციის.
    
- საჭიროა კონფიგურატორის დამატება, რომელიც უზრუნველყოფს რეცივერის მიწოდებას გამომგზავნელს და მოგიწევთ ყველა დიზაინერული არჩევანის განხილვა, რომელიც კონფიგურატორს ეკუთვნის.
    
- ან გამომგზავნელს ექნება Provided Interface, რათა კონფიგურატორმა გადასცეს რეცივერი, ან გამომგზავნი იძახებს კონფიგურატორს დამატებით რეცივერის მისაღებად.
    
- ან გამომგზავნს ექნება ერთი დამატებითი ლოკალური ცვლადი რეცივერის შესანახად, ან საჭიროებს რეცივერის მიღებას ყოველი გამოძახებისას.
    
- სტატიკურად ტიპდამოწმებულ ენებში, გამომგზავნმა უნდა გამოაცხადოს ინტერფეისი, რომელიც ყველა რეცივერს უნდა დაემთხვეს. (ეს არ არის საჭირო დინამიკურ ენებში.)
    
- სტატიკურად ტიპდამოწმებულ ენებში, ინტერფეისის გამოცხადება ზრდის სირთულეს წყაროს კოდის საქაღალდეების სტრუქტურაში.
    

## ზედმეტობის ეფექტი (Overdose Effect):

- თუ Configurable Receiver-ებს ყველგან დააყენებთ, თქვენი კოდი არასაჭიროდ დაიფარება და უგულებელყოფილი გახდება.



შემდეგი [[განხილვა Dependency Inversion, Injection, Lookup]]