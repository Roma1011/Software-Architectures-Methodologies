

**HaT ტექნიკური ანგარიში 2005.02**  
**თარიღი:** 2005-09-04  
**ავტორი:** ალისტერ კოკბერნი

დააპროექტე შენი აპლიკაცია ისე, რომ მუშაობდეს როგორც მომხმარებლის ინტერფეისის (UI), ასევე მონაცემთა ბაზის გარეშე, რათა შეძლო ავტომატური რეგრესიული ტესტების გაშვება, აპლიკაციის მუშაობა მაშინაც კი, როცა ბაზა მიუწვდომელია, და აპლიკაციების ერთმანეთთან დაკავშირება მომხმარებლის ჩარევის გარეშე.


### პატერნი: პორტები და ადაპტერები _(ობიექტის სტრუქტურული პატერნი)_

**ალტერნატიული სახელი:** ექვსკუთხა არქიტექტურა

---

### განზრახვა

მიეცი აპლიკაციას შესაძლებლობა, თანაბრად იმართოს როგორც მომხმარებლების(Driving), ისე პროგრამების(Driven), ავტომატური ტესტებისა თუ ბეჩ-სკრიპტების მიერ, და რომ მისი განვითარება და ტესტირება შესაძლებელი იყოს განლაგების დროის ტექნოლოგიებისგან დამოუკიდებლად.

როდესაც აპლიკაციის გარედან პორტზე მოდის რაიმე მოვლენა, ტექნოლოგიისადმი სპეციფიური ადაპტერი მას გარდაქმნის საჭირო პროცედურულ გამოძახებად ან შეტყობინებად და გადასცემს აპლიკაციას. აპლიკაცია სრულიად უცოდინარია იმ მოწყობილობის ბუნებაზე, საიდანაც მოვლენა მოვიდა.

როდესაც აპლიკაციას რაიმეს გადაცემა სურს, ის აგზავნის მას პორტის საშუალებით ადაპტერში, რომელიც ამზადებს საჭირო სიგნალებს მიმღები ტექნოლოგიისთვის იქნება ეს ადამიანი თუ ავტომატური სისტემა.

აპლიკაცია ახორციელებს სემანტიკურად გამართულ ურთიერთობას ყველა მის გარშემო არსებულ ადაპტერთან, თავად კი არანაირი ცოდნა არ აქვს, თუ რა დგას ადაპტერის მეორე მხარეს.

---

![[Pasted image 20250711223807.png]]


### მოტივაცია

ერთ-ერთი მთავარი პრობლემა პროგრამული უზრუნველყოფის აპლიკაციებში წლების განმავლობაში იყო ბიზნეს ლოგიკის შეპარვა მომხმარებლის ინტერფეისის კოდში. ეს პრობლემა სამმაგ დისკომფორტს იწვევს: 

 პირველ რიგში, სისტემის ტესტირება ავტომატური ტესტ-სუიტებით შეუძლებელი ხდება, რადგან იმ ლოგიკის ნაწილი, რომელიც უნდა დატესტილიყო, დამოკიდებულია ხშირად ცვალებად ვიზუალურ დეტალებზე, როგორიცაა ველის ზომა და ღილაკის მდებარეობა; იმავე მიზეზით შეუძლებელი ხდება სისტემის გადართვა მომხმარებელზე ორიენტირებულ რეჟიმიდან პარტიული შესრულების რეჟიმზე; და კვლავ იმავე მიზეზით, რთული ან შეუძლებელია პროგრამის მართვა სხვა პროგრამიდან, როდესაც ეს საჭიროება ჩნდება.

ბევრ ორგანიზაციაში ამ პრობლემის გადაჭრის მცდელობაა ახალი ფენის შექმნა არქიტექტურაში, დაპირებით, რომ ამჯერად, ნამდვილად, ამ ფენაში არ შევა ბიზნეს ლოგიკა. თუმცა, იმის გამო, რომ არ არსებობს მექანიზმი ამ დაპირების დარღვევის გამოვლენისათვის, რამდენიმე წლის შემდეგ ორგანიზაცია აღმოაჩენს, რომ ახალი ფენა კვლავ სავსეა ბიზნეს ლოგიკით და ძველი პრობლემა დაბრუნდა.

წარმოვიდგინოთ ახლა, რომ აპლიკაციის მიერ შეთავაზებული ყველა ფუნქციონალი ხელმისაწვდომია API-ის (აპლიკაციის პროგრამული ინტერფეისის) ან ფუნქციის გამოძახების მეშვეობით. ასეთ შემთხვევაში, ტესტირების ან ხარისხის კონტროლის დეპარტამენტს შეუძლია აწარმოოს ავტომატური ტესტ-სკრიპტები აპლიკაციის წინააღმდეგ, რათა გამოავლინოს, დაარღვია თუ არა ახალმა კოდმა უკვე არსებული ფუნქციონალი. ბიზნეს ექსპერტებს შეუძლიათ შექმნან ავტომატური ტესტები GUI დეტალების დასრულებამდე, რაც პროგრამისტებს შეატყობინებს, სწორად შეასრულეს თუ არა თავიანთი დავალება (და ეს ტესტები გახდებიან ტესტირების დეპარტამენტის ძირითადი ინსტრუმენტი). აპლიკაციას ასევე შეუძლია იმუშაოს "თავის გარეშე" რეჟიმში (headless mode), სადაც მხოლოდ API ხელმისაწვდომია, და სხვა პროგრამებს შეუძლიათ ისარგებლონ მისი ფუნქციონალით  ეს ამარტივებს კომპლექსური აპლიკაციური კომპლექტების დიზაინს და ასევე საშუალებას აძლევს ბიზნესიდან-ბიზნესამდე მომსახურე აპლიკაციებს დაუკავშირდნენ ერთმანეთს ადამიანის მონაწილეობის გარეშე, ვებით. საბოლოოდ, ავტომატური ფუნქციური რეგრესიული ტესტები გამოავლენენ ბიზნეს ლოგიკის გაჟონვას პრეზენტაციის ფენაში. ორგანიზაციას შეუძლია ამოიცნოს და გამოასწოროს ეს გაჟონვა.

მსგავსი საინტერესო პრობლემა არსებობს აპლიკაციის მეორე მხარეს, სადაც აპლიკაციის ლოგიკა მჭიდროდ არის დაკავშირებული გარე ბაზასთან ან სხვა სერვისთან. როდესაც ბაზის სერვერი ვერ იძებნება, იცვლება ან ახლდება, პროგრამისტებს აღარ შეუძლიათ მუშაობა, რადგან მათი კოდი დამოკიდებულია ბაზის არსებობაზე. ეს იწვევს დაგვიანებას და ხშირად ადამიანებს შორის დაძაბულობას.

შეიძლება არ ჩანს, რომ ეს ორი პრობლემა დაკავშირებულია, მაგრამ მათ შორის სიმეტრია არსებობს, რაც ჩანს ამ პრობლემების გადაწყვეტის ბუნებაში.



### გადაწყვეტის ბუნება

მომხმარებლის მხარისა და სერვერის მხარის ორივე პრობლემა გამოწვეულია ერთი და იმავე დიზაინის და პროგრამირების შეცდომით — ბიზნეს ლოგიკის და გარე ობიექტებთან ურთიერთობის გადახლართულობით. იმ ასიმეტრიის გამოსაყენებლად, რომლის გამოყენებაც საჭიროა, არ არის მარცხენა და მარჯვენა მხარეების, არამედ აპლიკაციის შიდა და გარე მხარეების განსხვავება. დასაცავი წესი არის ის, რომ აპლიკაციის შიდა კოდი არ უნდა გავრცელდეს გარე კოდზე.

თუ დროებით დავივიწყებთ მარცხენა-მარჯვენა ან ზემოთ-ქვემოთ მიმართულებებს, ვნახავთ, რომ აპლიკაცია ეცდება გარე სააგენტოებთან კომუნიკაციას პორტების მეშვეობით. სიტყვა "პორტი" უნდა აღძრას ასოციაცია საოპერაციო სისტემის პორტებთან, სადაც ნებისმიერი მოწყობილობა, რომელიც აკმაყოფილებს პორტის პროტოკოლს, შეიძლება იქ დაუკავშირდეს; ან ელექტრონული მოწყობილობის პორტებთან, სადაც ნებისმიერი მოწყობილობა, რომელიც შეესაბამება ფიზიკურ და ელექტრულ სტანდარტებს, ასევე შეიძლება დაუკავშირდეს. პორტის პროტოკოლი განისაზღვრება ობიექტებს შორის ურთიერთობის დანიშნულებით და რეალიზებულია როგორც API (აპლიკაციის პროგრამული ინტერფეისი).

ყველა გარე მოწყობილობისთვის არსებობს ადაპტერი, რომელიც გარდაქმნის API-ს შესაბამის სიგნალებად და პირიქით. გრაფიკული მომხმარებლის ინტერფეისი (GUI) არის ადაპტერის მაგალითი, რომელიც მომხმარებლის ქმედებებს პორტის API-ად გარდაქმნის. სხვა ადაპტერებია: ავტომატური ტესტირების ჩარჩოები (მაგ., FIT ან FitNesse), batch დამმუშავებლები, და ის კოდები, რომლებიც გამოიყენება აპლიკაციებს შორის კომუნიკაციისთვის.

აპლიკაციის მეორე მხარეს, ის მიიღებს მონაცემებს გარე წყაროდან. ამ კომუნიკაციის პროტოკოლი ხშირად ბაზის პროტოკოლია. აპლიკაციის ხედვით, თუ ბაზა შეიცვლება SQL ბაზიდან ბრტყელ ფაილზე ან სხვა ტიპზე, API-ზე საუბარი არ უნდა შეიცვალოს. იგივე პორტისთვის შესაძლებელი უნდა იყოს სხვადასხვა ადაპტერი: SQL ადაპტერი, ბრტყელი ფაილის ადაპტერი და — რაც მთავარია — "მოკ" (mock) ბაზის ადაპტერი, რომელიც მუშაობს მეხსიერებაში და საერთოდ არ საჭიროებს რეალურ ბაზას.

ბევრ აპლიკაციას მხოლოდ ორი პორტი აქვს: მომხმარებელზე ორიენტირებული დიალოგი და ბაზის მხარის დიალოგი. ეს ქმნის ასიმეტრიულ იერსახეს და ქმნის შთაბეჭდილებას, რომ აპლიკაცია ბუნებრივად უნდა აშენდეს ერთგანზომილებიანი, სამ-, ოთხ-, ან ხუთფენიანი სტრუქტურით.

ამ ნახატებთან ორი პრობლემა არსებობს. პირველი და ყველაზე ცუდი: ადამიანები არ აღიქვამენ ამ ფენებს სერიოზულად. ისინი დაუშვებენ ბიზნეს ლოგიკის გაჟონვას ფენებს შორის, რაც ზემოთ აღწერილ პრობლემებს იწვევს. მეორე: შეიძლება აპლიკაციას მეტი პორტიც ჰქონდეს, რაც არქიტექტურას ერთგანზომილებიან ფენოვან დიაგრამაში ვერ ათავსებს.

ექვსკუთხა, ანუ პორტებისა და ადაპტერების არქიტექტურა, ამ პრობლემებს წყვეტს სიმეტრიის გამოყოფით: შიგნით არის აპლიკაცია, რომელიც კომუნიკაციას ამყარებს გარეთ მდგომ ობიექტებთან რამდენიმე პორტის მეშვეობით. გარეთ მყოფ ობიექტებს შეგვიძლია სიმეტრიულად ვუმკურნალოთ.

**Hexagon** ვიზუალურად გამოკვეთს შიდა-გარე ასიმეტრიას და პორტების მსგავს ბუნებას, გვაშორებს ერთგანზომილებიან ფენოვან გამოსახულებას და ხაზს უსვამს პორტების ცხადად განსაზღვრულ რაოდენობას — ორს, სამს ან ოთხს (ოთხი ყველაზე მეტია, რაც მე მინახავს).

ექვსკუთხედი არა იმიტომაა არჩეული, რომ რიცხვი "ექვსი" რაიმე განსაკუთრებულს ნიშნავს, არამედ იმიტომ, რომ ხატვისას ადამიანებს ჰქონდეთ ადგილი პორტებისა და ადაპტერების ჩასამატებლად და არ იყვნენ შეზღუდულნი ფენოვანი დიაგრამის ჩარჩოებით. სწორედ ამ ვიზუალური მიზეზის გამო ეწოდა ამ არქიტექტურას "Hexagonal Architecture".

ტერმინი "Ports and Adapters" ასახავს დიაგრამის ნაწილების დანიშნულებას. პორტი განსაზღვრავს მიზანმიმართულ კომუნიკაციას. ერთი პორტისთვის, წესით, მრავალი ადაპტერი იარსებებს სხვადასხვა ტექნოლოგიისთვის. ეს შეიძლება იყოს სატელეფონო ავტომოპასუხე, ადამიანის ხმა, ღილაკიანი ტელეფონი, გრაფიკული ინტერფეისი, ტესტ ჰარნესი, batch-სკრიპტი, HTTP ინტერფეისი, პროგრამიდან პროგრამაში პირდაპირი ინტერფეისი, მოკ ბაზა (მეხსიერებაში), რეალური ბაზა (შეიძლება სხვადასხვა იყოს განვითარების, ტესტის ან რეალური გამოყენებისთვის).

აპლიკაციის შენიშვნების ნაწილში კვლავ შეგვხვდება მარცხენა-მარჯვენა ასიმეტრია, თუმცა ამ პატერნის მთავარი მიზანია ყურადღების გადატანა შიდა-გარე ასიმეტრიაზე — დროებით წარმოვიდგინოთ, რომ ყველა გარე ელემენტი ერთნაირია აპლიკაციის ხედვის კუთხით.



**სტრუქტურა**  
![[Pasted image 20250711223945.png]]

სურათი  აჩვენებს აპლიკაციას, რომელსაც აქვს ორი აქტიური პორტი და თითოეული პორტისთვის რამდენიმე ადაპტერი. ეს ორი პორტია აპლიკაციის მართვის მხარე და მონაცემების ამოღების მხარე. ნახატზე ჩანს, რომ აპლიკაცია შეიძლება ერთნაირად იმართებოდეს ავტომატიზებული სისტემური რეგრესიების სატესტო სუიტით, ადამიანის მომხმარებლით, შორეული HTTP აპლიკაციით, ან სხვა ლოკალური აპლიკაციით. მონაცემების მხარეს, აპლიკაცია შეიძლება დაკონფიგურდეს ისე, რომ იმუშაოს გარე მონაცემთა ბაზებისგან დამოუკიდებლად — მეხსიერებაში მოთავსებული "oracle"-ით ანუ mock მონაცემთა ბაზით; ან ასევე იმუშაოს სატესტო ან საოპერაციო მონაცემთა ბაზასთან. აპლიკაციის ფუნქციური სპეციფიკაცია (შეიძლება იყოს Use Case-ებში) შედგენილია hexagon-ის შიდა ინტერფეისზე დაყრდნობით და არა იმ ტექნოლოგიებზე, რომლებიც შეიძლება გამოყენებულ იქნას გარე მხარეს.

![[Pasted image 20250711224020.png]] 
სურათი  აჩვენებს იმავე აპლიკაციას რუტინულ სამ-საფეხურიან არქიტექტურულ ნახატში. გამოსახულების გამარტივების მიზნით, თითოეული პორტისთვის მხოლოდ ორი ადაპტერია ნაჩვენები. ნახატი გვიჩვენებს, როგორ თავსდება რამდენიმე ადაპტერი ზედა და ქვედა ფენებში, და თანმიმდევრობას, რომლითაც სხვადასხვა ადაპტერი გამოიყენება სისტემის განვითარების პროცესში. ისრებით დანომრვით მოცემულია ის ნაბიჯები, რომლითაც გუნდი შეიძლება მიჰყვეს აპლიკაციის განვითარებას:

1. FIT სატესტო ჰარნესი მართავს აპლიკაციას და იყენებს mock (მეხსიერებაში არსებულ) მონაცემთა ბაზას ნამდვილის ნაცვლად;
    
2. GUI-ს დამატება აპლიკაციაში, ჯერ კიდევ mock ბაზაზე;
    
3. ინტეგრაციის ტესტირება — ავტომატური ტესტ სკრიპტებით (მაგ. Cruise Control-დან) აპლიკაციის მართვა ნამდვილი, სატესტო მონაცემებით დატვირთული ბაზის წინააღმდეგ;
    
4. რეალურ გამოყენებაში — ადამიანი იყენებს აპლიკაციას ცოცხალი მონაცემთა ბაზასთან.


შემდეგი [[აპლიკაციის შენიშვნები]]