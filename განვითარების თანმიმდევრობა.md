განვითარების მოკლე თანმიმდევრობა ასეთია:

1. **ტესტიდან ტესტამდე**: შექმენი ტესტი როგორც აპის პირველი დრაივერი და დააკავშირე ის ტესტ დუბლთან (მეხსიერებაში, mock, stub, fake და სხვ.).
    
2. **რეალიდან ტესტამდე**: ჩასვი წარმოების დრაივერი, რომელიც დაკავშირებულია ტესტ დუბლთან.
    
3. **ტესტიდან რეალამდე**: დააკავშირე ტესტები production ბაზასთან, ან ტესტის ბაზასთან, რომელიც იყენებს იმავე ტექნოლოგიას, რასაც production ბაზა.
    
4. **რეალიდან რეალამდე**: ბოლოს, როცა ყველაფერი მუშაობს, დააკავშირე production დრაივერი და production ბაზა.
    

მას შემდეგ, რაც პირველ ნაბიჯს დაასრულებ, არქიტექტურა უკვე ჩამოყალიბებულია.  
ამის შემდეგ შეგიძლია დანარჩენი ნებისმიერი თანმიმდევრობით გააკეთო.  
განსაკუთრებით, ნაბიჯები 2 და 3 შეიძლება გადაცვალო ადგილებით.

![[Pasted image 20250707213443.png]]

გრძელი ახსნა არამარტო გრძელია, არამედ სხვადასხვა ენებისთვის განსხვავებულია.  
დეტალური ინსტრუქციები ტიპის განმსაზღვრელი ენებისთვის, როგორიცაა Java, განსხვავდება არატიპიზირებული ენებისგან, როგორიცაა Ruby.  
ამიტომ გადავწყვიტეთ, რომ უფრო გაგებადია თუ ცალკე იქნება დაწერილი.

აი რამდენიმე საერთო შენიშვნა ორივე თანმიმდევრობისთვის:

- ჩვენ ვაჩვენებთ ყველაზე გავრცელებულ კონფიგურატორს, სადაც დრივენ აქტორი გადაეცემა აპს აპის კონსტრუქტორის მეშვეობით.  
    
- ფოლდერების მოწყობისთვის, ალისტერის სწავლება შეიცვალა იმ მომენტიდან, როცა ხალხს ფაილების შექმნამდე ფოლდერების დაყენება სთხოვა.  
    რაც ადრე ადამიანებისთვის გაუგებარი იყო, მაშინვე გასაგები გახდა.  
    როცა ფოლდერები ადგილზეა, ნათელია, სად უნდა მოათავსო ყველაფერი.  
    ამიტომ **ნაბიჯი 0** ორივე თანმიმდევრობაში არის ფოლდერების სტრუქტურის დაყენება.
    
- ჩვენ გირჩევთ გამოიყენოთ **“[[მოსიარულე ჩონჩხის” (Walking Skeleton)]]** შაბლონი კოდის გასაზრდელად. ამ შაბლონის მიხედვით:
    - პირველ რიგში ვაყენებთ აპში უმცირეს ქცევას, რაც საკმარისია არქიტექტურის ასაწყობად და დასაკავშირებლად.  
        ანუ, პირველი ნაბიჯი შემოაქვს მხოლოდ დრაივინგ პორტს, მაგრამ არა დრივენს და აპი უბრალოდ აბრუნებს მუდმივ მნიშვნელობას.
        
    - მეორე ნაბიჯი შემოიყვანს ერთ დრივენ პორტს ტესტ დუბლთან ერთად. ამ მომენტში Ports & Adapters არქიტექტურა უკვე აწყობილია.



### განვითარების თანმიმდევრობა ტიპდეკლარირებული ენებისთვის

ეს თანმიმდევრობა განკუთვნილია ისეთი ენებისთვის, როგორებიცაა Java, სადაც ტიპები და ინტერფეისები საჭიროა დეკლარირებისთვის.

---

 ფოლდერების სტრუქტურის დაყენება

- შექმენი ფოლდერები ან პროექტები, სადაც განათავსებ აპის კოდს და პორტების დეკლარაციებს.
    
- ამ ფოლდერში შექმენი სამი ქვე-ფოლდერი:
    
    - ერთი აპის ბიზნეს ლოგიკისთვის,
        
    - ერთი "Driving Ports"-ისთვის,
        
    - და ერთი "Driven Ports"-ისთვის.
        
- ალტერნატივად, შეგიძლია პორტების ფოლდერი გამოყო ცალკე და მოათავსო აპის ფოლდერის ან პროექტის იმავე დონეზე.
    
- აპის სივრცის მიღმა, შენი კოდირების ტრადიციების შესაბამისად, შექმენი ორი ფოლდერი:
    
    - "Driving Adapters"
        
    - და "Driven Adapters".
        
- შექმენი ფოლდერი, სადაც დაწერ შენი driving ტესტებს.
    

---

## Driving მხარე ტესტი აპისთვის, რომელიც აბრუნებს მუდმივ მნიშვნელობას  

პირველი driving პორტის ჩამოყალიბება.  
რადგან ამ ეტაპზე ჩვენი მიზანია მხოლოდ driving მხარის არქიტექტურის ჩამოყალიბება, აპმა უნდა დააბრუნოს მხოლოდ მუდმივი მნიშვნელობა: `0`, `"Hi"` ან რამე მსგავსი მარტივი. აი, როგორ მიდის პროცესი:

- **"Driving Ports"** ფოლდერში დაამატე ფაილი შენი პირველი პორტის/ინტერფეისის დეკლარაციისთვის.  
    დაარქვი ინტერფეისს სახელი ფორმატით `"ForAccomplishingSomething"` — იმ სერვისის შესაბამისად, რომელსაც აპი უნდა აწვდიდეს.
    
- დეკლარაცია გააკეთე იმ ფუნქციის სიგნატურისთვის, რომელსაც პარამეტრები არ აქვს და აბრუნებს მხოლოდ მარტივ მნიშვნელობას.
    
- აპის ფოლდერში შექმენი უმარტივესი აპი driving ინტერფეისის მოსამსახურებლად.  
    ამ პირველ ეტაპზე ის არგუმენტებს არ იღებს და მხოლოდ აბრუნებს მუდმივს.  
    მან უნდა გამოაცხადოს, რომ `"აპი იმპლემენტაციას უწევს"` driving ინტერფეისს (შესაბამისად ენაზე).
    
- ტესტის ფოლდერში დაწერე ტესტი, რომელიც გამოიძახებს ამ ფუნქციას და ელოდება შესაბამის პასუხს.  
    ტესტის კოდს შესაძლოა დასჭირდეს ინტერფეისის იმპორტი, დამოკიდებული ენასა და კოდირების წესებზე.
    
- გაუშვი ტესტი. იმედი გვაქვს, რომ ჩაივლის. თუ არა — დაალაგე ყველაფერი, რაც საჭირო იქნება სწორი შეერთებისთვის.





### Driven მხარე ტესტი — მართული აქტორი აბრუნებს მუდმივ მნიშვნელობას

ახლა დაამატე **მართული პორტი**:

- **Driven Ports** ფოლდერში, აღწერე მხოლოდ ერთი ინტერფეისი ერთ ფუნქციური სიგნატურით მართული აქტორისთვის.  
    გამოიყენე რაც შეიძლება მარტივი ინტერფეისი — იდეალურად, პარამეტრების გარეშე.  
    ინტერფეისს დაარქვი `"ForAccomplishingXYZ"` მსგავსი სახელი — იმ სერვისის მიხედვით, რაც აპს სჭირდება მართული აქტორისგან.  
    ეს იქნება არგუმენტებისა და ცვლადების ტიპი, რომლებიც მართულ აქტორს ინახავენ.
    
- **Driven Adapters** ფოლდერში დაამატე კლასი, რომელიც იმპლემენტაციას გაუწევს ამ მოთხოვნილ ინტერფეისს და დააბრუნებს მარტივ მნიშვნელობას.  
    ამით გექნება შენი პირველი მართული აქტორი. დარწმუნდი, რომ კოდში მითითებულია, რომ ის `"იმპლემენტაციას უწევს"` მოთხოვნილ ინტერფეისს.
    

> შენიშვნა: ეს კლასი არის **ტესტ დუბლი**. ის სინამდვილეში აქტორია და არა ადაპტერი.  
> რომ ავირიდოთ ტერმინოლოგიური დაბნეულობა, ვიყენებთ სიტყვას **"ინტერაქტორი"** — რაც ნიშნავს "ადაპტერი ან აქტორი, რომელსაც ადაპტერი არ სჭირდება."  
> ეს ტესტ დუბლი არის მაგალითი აქტორის, რომელსაც ადაპტერი არ სჭირდება.

---

ახლა შეცვალე აპი ისე, რომ გამოიყენოს ეს მართული ინტერაქტორი (ტესტ დუბლი):

- დაამატე ინსტანს ცვლადი მართული ინტერაქტორის შესანახად.  
    ცვლადის ტიპი უნდა იყოს ახლახან აღწერილი მართული ინტერფეისი `"ForAccomplishingXYZ"`.
    
- დაამატე კონსტრუქტორი, რომელიც მიიღებს მართულ ინტერაქტორს არგუმენტად და შეინახავს ცვლადში.  
    არგუმენტის ტიპი ასევე უნდა იყოს `"ForAccomplishingXYZ"` და არა კონკრეტული კლასის ტიპი.
    
- შეცვალე კოდი ისე, რომ მუდმივის დაბრუნების ნაცვლად, მართული ინტერაქტორისგან მოითხოვოს შედეგი და ის დააბრუნოს.
    

---

**დაკომენტარე, წაშალე ან შეცვალე პირველი ტესტ ქეისი:**

- შექმენი ახალი მართული ინტერაქტორი (ტესტ დუბლი).  
    გამოაცხადე მისი ტიპი როგორც მართული ინტერფეისი და არა როგორც მისი კლასი.
    
- შექმენი აპის ობიექტი, გაატარე მას ეს ინტერაქტორი კონსტრუქტორით.
    
- ტესტში შეამოწმე, რომ აპი აბრუნებს იმ მარტივ მნიშვნელობას, რასაც ტესტ დუბლი აბრუნებს.  
    ჩვენ გირჩევთ, განსხვავებული მნიშვნელობა გამოიყენო, ვიდრე პირველ ტესტში, რათა დარწმუნდე, რომ ცვლილებები სწორად განხორციელდა.




### Driving მხარე დაამატე რეალური driving აქტორი

ამ ეტაპზე შენ მუშაობ შენს მიერ არჩეულ ტექნოლოგიაში. ეს შეიძლება იყოს:

- ადამიანური ინტერფეისი
    
- ვებ ინტერფეისი
    
- მიკროსერვისი
    
- ან ნებისმიერი სხვა, რაც შენ შეარჩიე
    

 საჭიროების შემთხვევაში დაამატე ადაპტერი `"Driving Adapters"` ფოლდერში.  
მაგალითად, ვებ ინტერფეისისთვის შეიძლება დაგჭირდეს ადაპტერი,  
მაგრამ შესაძლოა მიკროსერვისის სახით გამოყენებისას არ დაგჭირდეს.

 ადამიანისთვის UI-ის შექმნისას გამოიყენე შენთვის სასურველი სტრუქტურა.  
ამ ეტაპზე, როგორ იმუშავებ, შენზეა დამოკიდებული.

 შესაძლოა დაგჭირდეს გამოაცხადო, რომ შენი ადაპტერი ან driving აქტორი **"იყენებს"** driving პორტის აღწერას.

 **საფეხურ 3-ის ბოლოს** შენს სისტემას უკვე ეყოლება ორი დრაივერი (ტესტ დრაივერი და რეალური), თუმცა ის ჯერ ისევ დაკავშირებულია ტესტ დუბლთან.

---

### Driven მხარე დაამატე რეალური რეპოზიტორიუმი ან მიმღები

 აირჩიე ტექნოლოგია შენს მართულ აქტორზე. ეს შეიძლება იყოს:

- ფაილი მონაცემებით
    
- ბაზის ინტერფეისი
    
- წვდომა ინტერნეტთან
    
- ან ნებისმიერი სხვა, რაც საჭიროდ მიგაჩნია
    

 `"Driven Adapters"` ფოლდერში დაამატე ადაპტერი,  
რომელიც **გამოაცხადებს და იმპლემენტაციას გაუწევს** იმავე მართულ ინტერფეისს.  
დაამატე რეპოზიტორიუმი ან მიმღები იქ, სადაც შენთვის სწორია.

 ამ ეტაპზე, უკვე გეყოლება მრავალი driving და driven აქტორი — არქიტექტურა უკვე მოქმედებს.

 დაამატე მეტი driving და driven პორტი და აქტორი ორივე მხარეს, საჭიროების შესაბამისად.






### **განვითარების თანმიმდევრობა არატიპდეკლარირებული ენებისთვის**

შემდეგი ინსტრუქცია განკუთვნილია ისეთი ენებისთვის, როგორიცაა **Ruby**, სადაც არ არის აუცილებელი ტიპების ან ინტერფეისების დეკლარაცია. როგორც წინა შემთხვევაშიც, ვირჩევთ ყველაზე გავრცელებულ **კონფიგურატორს**, რომელშიც მართული აქტორი გადაეცემა აპს მისი **კონსტრუქტორის** მეშვეობით. თავდაპირველად ვაწყობთ **ფოლდერების სტრუქტურას**, და ვიყენებთ **Walking Skeleton** შაბლონს.

---

### 0: მომზადება ფოლდერის სტრუქტურის შექმნა

- შექმენი ფოლდერი, სადაც განათავსებ აპის კოდს.
    
- აპის გარე სივრცეში (შენს კოდირების კონვენციებზე მორგებულ ადგილას), შექმენი ორი ფოლდერი:
    
    - `driving_adapters`
        
    - `driven_adapters`
        
- შექმენი ფოლდერი, სადაც განათავსებ ტესტებს (მაგ., `tests` ან `driving_tests`).
    

---

### Driving მხარე უბრალოდ დატესტე აპი, რომელიც აბრუნებს კონსტანტას**

დაამყარე პირველი driving აქტორი. ამ ეტაპზე მიზანია არქიტექტურის driving მხარის შექმნა, ამიტომ აპი უბრალოდ უნდა აბრუნებდეს კონსტანტას: მაგალითად `0`, `"Hi"` ან სხვა მარტივ მნიშვნელობას.

 აპის ფოლდერში შექმენი ყველაზე მარტივი ვერსია, რომელიც არ იღებს არგუმენტებს და აბრუნებს კონსტანტას.

 ტესტების ფოლდერში დაწერე ტესტი, რომელიც იძახებს ამ ფუნქციას და ელოდება იმავე მნიშვნელობას.

 გაუშვი ტესტი. იმედია, წარმატებით ჩაივლის. თუ არა — შეასწორე კოდი და დარწმუნდი, რომ კავშირი სწორად მუშაობს.



>  შენიშვნა: ეს ტესტი შემდგომში წაიშლება, რადგან ყველა მომავალი ტესტი და პროდუქტიული კოდი უკვე მართულ აქტორებზე იქნება დამოკიდებული. ამ ტესტის შენარჩუნება გამოიწვევს უსარგებლო კოდის გაჩენას, ამიტომ, სიმძიმით გულში და ცრემლებით თვალებში მოგვიწევს მისი დაკომენტარება ან წაშლა. მან თავისი დანიშნულება უკვე შეასრულა.

---

###  Driven მხარე დატესტე მართული აქტორი, რომელიც აბრუნებს კონსტანტას

ახლა დაამატე მართული აქტორი:

 `driven_adapters` ფოლდერში შექმენი კლასი, რომელიც აბრუნებს მარტივ მნიშვნელობას. ეს იქნება შენი პირველი მართული აქტორი.

>  შენიშვნა: ეს კლასი არის ტესტ დუბლი. რეალურად ის არის **აქტორი**, და არა **ადაპტერი**. ტერმინოლოგიური დაბნეულობის თავიდან ასაცილებლად, ვიყენებთ სიტყვას **interactor**, რაც ნიშნავს: ადაპტერი ან აქტორი, რომელსაც ადაპტერი არ სჭირდება. ეს ტესტ დუბლი სწორედ ასეთი ინტერაქტორია.

 ახლა შეცვალე აპი, რომ გამოიყენოს ეს driven interactor:

- დაამატე ინსტანს ვარიაბლი, რომელიც შეინახავს მართულ ინტერაქტორს.
    
- დაამატე კონსტრუქტორი, რომელიც მიიღებს ამ ინტერაქტორს და შეინახავს მას ვარიაბლში.
    
- შეცვალე კოდი ისე, რომ აღარ აბრუნებდეს სტატიკურ მნიშვნელობას, არამედ გამოიძახოს ის ინტერაქტორის მეშვეობით და დააბრუნოს შედეგი.
    

 შეცვალე პირველი ტესტი (ან წაშალე):

- შექმენი driven interactor-ის (ტესტ დუბლი) ინსტანცია.
    
- შექმენი აპის ინსტანცია და გადასცე ეს ტესტ დუბლი კონსტრუქტორში.
    
- დაწერე ტესტი, რომელიც ამოწმებს, რომ აპი აბრუნებს იმ მნიშვნელობას, რომელსაც აძლევს driven აქტორი. გამოიყენე განსხვავებული მნიშვნელობა, რათა დარწმუნდე, რომ ნამდვილად მოხდა კოდის შეცვლა.
    



- კონფიგურატორი
    
- driving პორტი
    
- driving აქტორი
    
- driven პორტი
    
- driven აქტორი
    
- და აპი, რომელიც მათ სწორად უკავშირდება
    

 ამ ეტაპიდან შეგიძლია სისტემა ნებისმიერი მიმართულებით განავითარო.

---

### **შემოკლებული აღწერა – მომდევნო ეტაპები:**

---

### Driving მხარე დაამატე რეალური driving აქტორი

ამ ეტაპზე უკვე იყენებ საკუთარ ტექნოლოგიას. ეს შეიძლება იყოს:

- მომხმარებლის ინტერფეისი
    
- ვებ ინტერფეისი
    
- მიკროსერვისი
    
- ან ნებისმიერი სხვა
    

 თუ საჭიროა, დაამატე ადაპტერი `"driving_adapters"` ფოლდერში. მაგალითად, ვებსერვისისთვის ადაპტერი შეიძლება დაგჭირდეს, მაგრამ მიკროსერვისისთვის — არა.

 მომხმარებლის ინტერფეისისთვის გამოიყენე შენთვის მისაღები ადგილი.

 **შენზეა დამოკიდებული**, როგორ გააკეთებ ამას. ამ ნაბიჯის ბოლოს, სისტემას უკვე ჰყავს **ორი driving აქტორი**, რომლებიც დაკავშირებული არიან ტესტ დუბლთან.

---

### Driven მხარე დაამატე რეალური საცავი ან მიმღები

აირჩიე ტექნოლოგია მართული აქტორისთვის:

- ფაილი
    
- მონაცემთა ბაზა
    
- ვებ-სერვისი
    
- ან რაც შენთვის სასურველია
    

 `"driven_adapters"` ფოლდერში დაამატე ადაპტერი, რომელიც იმავე ინტერფეისს ახორციელებს. დაამატე საცავი ან მიმღები იქ, სადაც საჭიროა.

 ამ ეტაპზე უკვე გაქვს **ორი driving** და **ორი driven** აქტორი.

 დაამატე მეტი driving/driven პორტები და აქტორები საჭიროებისამებრ — არქიტექტურა უკვე მუშაობს.