# Ports-and-Adapters

**ალიესტერ კოქბერნი**  
Humans and Technology Technical Report 2022.01 (v3a, 2023-06-01)  
© ალიესტერ კოქბერნი, 2022 ყველა უფლება დაცულია

**კომპონენტი + სტრატეგია საშუალებას გაძლევთ დააკონფიგურიროთ ქვესისტემა ისე, რომ იგი შეესაბამებოდეს  
სავარაუდოდ განსხვავებულ გარემოს.  
ჰექსაგონალური არქიტექტურა, იგივე Ports & Adapters, არის მისი სპეციფიკური ვერსია, რომელიც საშუალებას  
გვაძლევს გამოვყვეთ სისტემა გარედან შემოსული ტექნოლოგიებიდან, გავცვალოთ ეს ტექნოლოგიები და დავტესტოთ სისტემა იზოლაციაში ამ ტექნოლოგიებისგან.**

![[Pasted image 20250715225352.png]]

## Table of Contents:

1. Warmup
    
2. Introducing components and ports
    
3. Strategy, Adapter, or both?
    
4. The Pattern: Component + Strategy
    
5. Ports & Adapters (Hexagonal Architecture) revisited
    
6. The Hidden Fourth Object: the Configurator
    
7. Tests or no tests?
    
8. End Notes



## Warmup

ძალიან ბუნებრივია, ობიექტი გადასცე ფუნქციას არგუმენტად, რათა ამ ფუნქციამ შეეკითხოს ინფორმაციას ან დაავალოს მოქმედება. ეს არის ობიექტზე-ორიენტირებული დიზაინის ნორმალური პრაქტიკა.

მაგალითად, ვთქვათ პროგრამას წერთ ყავის აპარატისთვის, რომელიც რეცეპტებზე მუშაობს. შეგიძლიათ გადასცეთ რეცეპტის ობიექტი drink-maker-ს, რათა მან მისგან გამოიტანოს დოზირების თანმიმდევრობა.


```js
recipe = RecipeLibrary.find("mochaccino");
drinkmaker.make(recipe)

inside drinkmaker:
foreach step in recipe {
    dispenser = step.ingredient
    quantity = step.quantity
    dispenser.dispense(quantity)
}
```


![[Pasted image 20250715225500.png]]
### გარდაუვალი ყავის აპარატი

მიუხედავად იმისა, რომ ეს ყველაფერი საკმაოდ ნორმალურია, რეალურად იგი საკმაოდ დახვეწილია. მასზე ბევრი დაწერილა და ბევრი ფFancy დასახელებაც აქვს მინიჭებული.

პირველ რიგში, ჩვენ პარამეტრიზებული გვაქვს რეცეპტები, რაც ნიშნავს, რომ ვირჩევთ რომელს გამოვიყენებთ ფუნქციაში გადაცემული არგუმენტის მიხედვით. ეს არის ძალიან ბაზისური პროგრამირების ხერხი, და საკმაოდ გასაგები უნდა იყოს. ამას ვახსენებ იმიტომ, რომ ცოტა ხანში ვიტყვი ფრაზას: _"პარამეტრიზება მეორადი აქტორების"_. რასაც ვგულისხმობ, არის ის, რომ გადასცემ არგუმენტს, რომელიც იდენტიფიცირებს ვის გამოვიყენებთ.

გამოდის, რომ ჩვენ სწორედ **Strategy pattern**-ი დავნერგეთ.

ბევრი პროგრამისტი სტრატეგიის პატერნს არ იყენებს ცნობიერად, რადგან იგი საკმაოდ რთულადაა აღწერილი _Design Patterns_ წიგნში. ამიტომ ხშირად იყენებენ ინსტინქტურად, მაგრამ საკუთარ დიზაინს ასე არ ახასიათებენ.

**Strategy pattern** ძალიან მოკლედ ასე გამოიყურება:


![[Pasted image 20250715225548.png]]
### Strategy პატერნი

---

Strategy პატერნი ამბობს მხოლოდ იმას, რომ ობიექტს (აქ "Context") აქვს ერთ-ერთი ისეთი ობიექტი, რომელიც ერთსა და იმავე ფუნქციას ასრულებს. ეს უბრალო პოლიმორფიზმია.

დიაგრამაში კონკრეტული სტრატეგიები აღჭურვილია მშობელი სტრატეგიის ქვემდებარე კლასებით. მაგრამ ეს საჭირო არაა ყველა ენაში. Ruby-ში, Smalltalk-ში და მსგავს ენებში კონკრეტულ სტრატეგიებს უბრალოდ უნდა ჰქონდეთ შესაბამისი ფუნქციის ინტერფეისი, არ არის საჭირო აბსტრაქტული მშობლის კლასი. ეს მნიშვნელოვანი ხდება მოგვიანებით.

რაც Strategy-ს მაგარ პატერნად აქცევს, არის ის, რომ პოლიმორფიზმი არა მხოლოდ 'if'-ების მოცილებაში გვეხმარება, არამედ Context-ს საერთოდ არ აინტერესებს რომელი ობიექტი აქვს ხელში კონკრეტულ მომენტში.

Context შეიძლება თავად წყვეტდეს ადრე, რომელ ალგორითმს გამოიყენებს — დროის ოპტიმალიზებული, სივრცის ოპტიმალიზებული და ა.შ. — და შესაბამის ობიექტს ინახავს. შემდეგ, საჭიროებისას, ამუშავებს იმას, რაც ჰქონდა შენახული.

ან შესაძლოა Context-მა საერთოდ არ იცოდეს რა ტიპის ობიექტს უწოდებს. ვიღაც სხვამ გადაწყვიტა ეს და გადასცა პარამეტრად. ეს ზუსტად ისაა, რაც რეცეპტის ობიექტით გავაკეთეთ.

Strategy პატერნი არაფერს ამბობს იმაზე, როგორ ხდება კონკრეტული სტრატეგიის გადაცემა Context-ში — ეს მის ფარგლებს სცდება.

ამ სტატიაში ყურადღებას მივაქცევთ ამაზე — რას აწესებს პატერნი და რა რჩება მის ფარგლებს გარეთ.



მესამე მნიშვნელოვანი საკითხი, რაც ამ მაგალითში გამოვიყენეთ, არის UML-ის ტერმინით ე.წ. **Required Interface**. Drinkmaker განსაზღვრავს, თუ რა მეთოდებს გამოძახებს მის არგუმენტებზე და იმ ობიექტებმა ეს მეთოდები უნდა დააინპლემენტონ.

ეს ზუსტად არის ის, რასაც Strategy პატერნი გულისხმობს, მიუხედავად იმისა, რომ უბრალო მკითხველისთვის ეს შეიძლება არ ჩანდეს.

მაგრამ ჯერ არ დავამთავრეთ მაგალითი.

აღმოჩნდა, რომ ასევე გამოვიყენეთ **Dependency Injection** პატერნი — ანუ კონფიგურირებადი მიმღების (Configurable Receiver) ერთ-ერთი იმპლემენტაცია. [იხილეთ ბმული](https://alistaircockburn.com/Arcles/Configurable-Receiver)



![[Pasted image 20250715225642.png]]

UML დიაგრამაში:

- უბრალო ისრები გვიჩვენებს გამოძახებას ანუ driver იყენებს drinkmaker-ს.
    
- ღია სამკუთხედი გვიჩვენებს implement-ირებას. ყველა recipe უნდა აკმაყოფილებდეს drinkmaker-ის მოთხოვნილ ინტერფეისს.
    

ეს ორი ისარი იგივეა რაც Strategy პატერნის დიაგრამაშია, ოღონდ იქ გარე driver-ის გამოძახება არ არის ნაჩვენები, რადგან ეს პატერნის ფარგლებს სცდება.

იმის გამო, რომ driver გადასცემს recipe-ს drinkmaker-ს, drinkmaker-ს არ აქვს წარმოდგენა სხვა ობიექტებზე პროგრამირების დროს. მას არ აქვს არც ერთი კოდის დონეზე დამოკიდებულება მათზე. ყველაფერი რაც სჭირდება, გამოითხოვება შესრულების დროს.

ეს ყველაფერი დიდად მისაღებია შენარჩუნების, ტესტირებისა და გადამოწმების კუთხით.

---

ამ warmup სექციის დასასრულს, მინდა გაჩვენოთ თუ რამდენად ნორმალურია ობიექტის გადაცემა ფუნქციაში შემდგომი ოპერაციებისთვის და როგორ მოიცავს ეს ერთი უბრალო ქმედება შემდეგ buzzword-ებს:

- **parameterized collaborator**
    
- **Configurable Receiver**
    
- **Dependency Injection**
    
- **Strategy**
    
- **Required Interface**
    

ეს ყველაფერი საკმაოდ ნორმალური დიზაინის პრაქტიკის ნაწილია — მიუხედავად ზედმეტი სიტყვებით დატვირთულობისა.



## Introducing components and ports

მე მხოლოდ 2022 წელს აღმოვაჩინე(!), რომ UML-ში არსებობს რაღაც, რომელსაც ეწოდება **Component** (კომპონენტი), რომელსაც აქვს _Provided Interface_ ანუ API დამძრავის (driver) მხარეს და _Required Interface_ კოლაბორატორის მხარეს. უფრო მეტიც, კომპონენტს აქვს რაღაც, რასაც ჰქვია **Port** (პორტი), რაც უბრალოდ მოთხოვნაა იმაზე, რომ ნებისმიერი, რაც კომპონენტში იჩართება, უნდა იცავდეს გარკვეულ პროტოკოლს.


UML-ის სპეციფიკაცია ამბობს, რომ კომპონენტი არის:

> "მოდულარული ერთეული მკაფიოდ განსაზღვრული ინტერფეისებით, რომელიც შეიძლება შეიცვალოს საკუთარ გარემოში."

> "კომპონენტი განსაზღვრავს ფორმალურ კონტრაქტს იმ სერვისებზე, რომელსაც ის უზრუნველყოფს თავის კლიენტებისთვის და იმ სერვისებზე, რომელსაც ის მოითხოვს სხვა კომპონენტებისგან ან სისტემაში არსებული სერვისებისგან — თავისი _provided_ და _required_ ინტერფეისების თვალსაზრისით."

აქ არის UML-ის სურათი კომპონენტისთვის:  
![[Pasted image 20250715225950.png]]
UML კომპონენტი Provided და Required ინტერფეისებით

ერთ-ერთი ძირითადი თვისება კომპონენტებისა, რომელიც მნიშვნელოვანია ამ სტატიისთვის, არის ის, რომ ისინი შეიძლება ჩაშენებული იყვნენ ერთმანეთში — კომპონენტები კომპონენტების შიგნით — ნებისმიერი რაოდენობის შრეებად. ეს საშუალებას გაძლევთ ააგოთ ქვესისტემები ინდივიდუალური კომპონენტებისა და სხვა ქვესისტემებისგან. როცა ამას შევადარებთ _Ports & Adapters_ ანუ _Hexagonal Architecture_ ნიმუშს, რომელიც არ იშიფრება (არ აქვს ჩაშენება), ვნახავთ, რომ ეს არის ერთი მნიშვნელოვანი განსხვავება მათ შორის.


![[Pasted image 20250715230025.png]]
კომპონენტების ჩაშენება  
_(სურათი მოწოდებულია Juan Manuel Garrido de Paz-ის მიერ)_  
_(ადრე იყო: [https://www.uml-diagrams.org/componentdiagrams/component-diagram-overview.png](https://www.uml-diagrams.org/componentdiagrams/component-diagram-overview.png))_

საბოლოოდ უნდა აღვნიშნოთ, რომ სუფთა მოდელირების დისკუსიიდან გადავდივართ იმაზე, რაც მოიცავს _პაკეტირებას_ (packaging). პაკეტირება პირველ რიგში კონცეპტუალურია, რადგან ვაცხადებთ, რომ ობიექტების ერთობლიობას აქვს საზღვარი და განსაზღვრული ურთიერთქმედების გზები. ეს შეიძლება იყოს ფიზიკური პაკეტიც — შენახვის ან გამოქვეყნების ერთეული.

ახლა რასაც გავაკეთებთ, ცოტა უჩვეულოა — ჩვენ ავურევთ პაკეტირების დისკუსიას მოდელირების დისკუსიასთან ერთ ნიმუშში.  
ჩვენ ვაპირებთ ჩვენი კომპონენტის კონფიგურაციას _Strategy_-ით.

მაგრამ ჯერ უნდა ვკითხოთ: **Strategy? თუ Adapter?**



## Strategy, Adapter, or both?

**Adapter** ნიმუში არის **Strategy** ნიმუშის სპეციალური შემთხვევა, რომელშიც კონკრეტული სტრატეგია აკეთებს გარკვეულ კორექტირებებს ინტერფეისის თავსებადობაზე და შემდეგ იძახებს სხვა სერვისს მოთხოვნის შესასრულებლად.  
ძირითადი განსხვავება მათ შორის ის არის, რომ **Adapter** ნიმუშს აქვს დამატებითი ინდირექციის დონე. სტრატეგია შეიძლება ან ვერ შეიძლება თავად ასრულებდეს მთელ სამუშაოს, მაგრამ ადაპტერი _ნაგულისხმევად_ ზარმაცად უკავშირდება სხვას.

**Strategy** ობიექტი, რა თქმა უნდა, შეიძლება იგივე გააკეთოს — ეს ნიმუშის განსაზღვრების მიღმაა — მაგრამ ადაპტერს _ვიცით_, რომ ასე ექცევა.

ახლა, ვიცი რომ სახელები განსხვავდება, მაგრამ chwilით მინდა მხოლოდ კოდის სტრუქტურას შევხედოთ, რადგან ამას გამოვიყენებთ.

![[Pasted image 20250715230109.png]]

![[Pasted image 20250715230123.png]]

შეგიძლიათ შეამჩნიოთ, რომ დიაგრამაში Adapter-ს მხოლოდ ერთი ადაპტერი აქვს, ხოლო Strategy-ს — რამდენიმე, რაც წარმოაჩენს სავარაუდოდ გამოცვლად კონკრეტულ სტრატეგიებს. მაგრამ ეს მხოლოდ ნახატშია ასე.  
რეალურ პრაქტიკაში ჩვენ საკმაოდ ხშირად ვაგზავნით შეტყობინებას ვებსერვისში, ტექტური შეტყობინებით ან სხვაგან — და ესეც იცვლება პროგრამის შესრულების დროს. ასე რომ, ჩვეულებრივ, შეიძლება არსებობდეს რამდენიმე კონკრეტული Adapter კლასი, რომელიც გამოძახებული და შეცვლილი იქნება კონფიგურაციის ან შესრულების დროს.

სადაც ეს მსგავსება ნიმუშებს შორის ხდება გამოსადეგი არის ის, რომ **შეგიძლიათ გააერთიანოთ Strategy და Adapter**. ქვემოთ მოცემული მაგალითი აჩვენებს მათ ერთდროულად.  
პირველი სტრატეგია შესაძლოა _მთელ_ სამუშაოს ასრულებდეს თვითონ, ხოლო მეორე იყენებს მესამე ობიექტს სამუშაოს დასასრულებლად.


![[Pasted image 20250715230214.png]]
Strategy და Adapter ერთად  
[წყარო](http://www.w3sdesign.com/GoF_Design_Paerns_Reference0100.pdf)

ჩვენ გამოვიყენებთ ამ გაერთიანებულ ნიმუშს ჩვენი კომპონენტის ტესტირებისას.

ზემოაღნიშნული მიზეზების გამო, ამ სტატიაში ნიმუშს ვუწოდებ **Component + Strategy**.  
შემდგომში მას სპეციალიზაციას გავუწევ _Ports & Adapters_ ანუ _Hexagonal Architecture_-ის ფორმაში.



## The Pattern: Component + Strategy

**Component + Strategy** გაძლევთ საშუალებას დააკონფიგურიროთ ქვესისტემა ისე, რომ მოერგოს ოდნავ განსხვავებულ გარემოებებს.

რადგან გვაქვს პაკეტირების ელემენტი დაკავშირებული მოდელირების ელემენტთან, ნიმუშს ორ დიაგრამად წარმოვადგენ:

- კომპონენტის დიაგრამა, რომელზეც ერთი ობიექტია მიმაგრებული
    
- კლასების დიაგრამა, რომელზეც კომპონენტი ერთი კლასითაა წარმოდგენილი (თუმცა ის ალბათ ბევრია)
    

პირველად, უბრალოდ რომ შევეჩვიოთ მათ ყურებას, აი Strategy ნიმუში კომპონენტის დიაგრამის სახით:

![[Pasted image 20250715230254.png]]
Strategy როგორც კომპონენტის დიაგრამა  

შემდეგ, აი **Component + Strategy** კომპონენტის დიაგრამის სახით:

![[Pasted image 20250715230320.png]]
Component + Strategy კომპონენტის დიაგრამად  


და ბოლოს, აი **Component + Strategy** კლასების დიაგრამის სახით:

![[Pasted image 20250715230337.png]]
Component + Strategy როგორც კლასების დიაგრამა  



**Component + Strategy** გამოყენების ერთ-ერთი სარგებელი ის არის, რომ როდესაც კომპონენტის საზღვარს მკაფიოდ ვაცხადებთ, შეგვიძლია გარე აქტორისთვის მივაწოდოთ ტესტური სტრატეგია და ამით დავტესტოთ კომპონენტი იზოლაციაში.  
შემდეგ კი წარმოებისთვის მივაწვდით ადაპტერს რეალური კავშირის დასამყარებლად.

აი, ახლა ჩვენი Strategy-Adapter დისკუსია ხორციელდება.

ტესტური ობიექტი შეიძლება არ იყოს დაკავშირებული ტესტის ბაზასთან.  
თუ არაა, მაშინ ის აკმაყოფილებს Strategy ობიექტის განმარტებას, როგორც ზემოთ განვიხილეთ.  
თუ დაკავშირებულია ტესტურ ბაზასთან — მაშინ ის შეიძლება ჩაითვალოს Adapter-ად.

პირადად მე, არ ვდარდობ როგორ დავარქმევთ — არ ღირს დროის ხარჯვა ამაზე კამათში.

უბრალოდ ამ დეტალებს იმიტომ ვუსვამ ხაზს, რომ ეს ნიმუშის აღწერაა და მინდა ტერმინოლოგიურად მაქსიმალურად ზუსტი ვიყო.

ბოლოს, ამ ყველაფრის გათვალისწინებით, ვირჩევ ნიმუშის სახელად **Component + Strategy**, და არა **Component + Adapter**, რადგან Strategy უფრო ზოგადია ამ ორისგან.