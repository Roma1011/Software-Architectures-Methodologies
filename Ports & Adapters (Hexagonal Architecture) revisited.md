
![[Pasted image 20250801232912.png]]
ზემოთ თქმულის გათვალისწინებით, ახლა შეგვიძლია ვნახოთ, რომ **Ports & Adapters**, ასევე ცნობილი როგორც **Hexagonal Architecture**, არის **Component + Strategy**-ს კონკრეტული გამოყენება, სადაც კომპონენტის საზღვარი განთავსებულია პირდაპირ გარე ტექნოლოგიების წინ.  
Adapter ობიექტები მიეწოდება თითოეული პორტისთვის, რათა შეესაბამებოდეს კომპონენტის _Provided Interface_-ს ან _Required Interface_-ს.

თუ საქმე გვაქვს პირდაპირი მოდულიდან მოდულში ინტერაქციასთან, სადაც ინტერფეისები თავსებადია, შეიძლება ადაპტერი საერთოდ არ იყოს საჭირო.

![[Pasted image 20250801232944.png]]
აპლიკაციები, რომლებიც ურთიერთობენ ადაპტერის საჭიროებით ან მის გარეშე

ტესტირებისას, **ტესტური ობიექტები** შეიძლება იყვნენ ან Strategy, ან Adapter ობიექტები.

![[Pasted image 20250801233035.png]]
Ports & Adapters როგორც კომპონენტის დიაგრამა, რომელიც აჩვენებს ტესტურ ობიექტს

ორი ნიმუშის განსხვავებებიდან ერთ-ერთი ის არის, რომ **Ports & Adapters-ის მთავარი განზრახვაა გარე ტექნოლოგიების ცვლილებებისგან დაცვა.**  
ამიტომ მისი საზღვარი განთავსებულია მხოლოდ ტექნოლოგიის საზღვართან.  
ის _არ არის ჩაშენებადი_, განსხვავებით **Component + Strategy**-სგან, რომელიც ჩაშენებისთვის არის შექმნილი.

![[Pasted image 20250801233123.png]]
კომპონენტები Ports & Adapters-ის ფარგლებში


ტესტირება უნდა იყოს იგივე, როგორც **Ports & Adapters**-ისთვის და **Component + Strategy**-სთვის:  
მოათავსეთ ტესტური დრაივერი ან ტესტური ობიექტი თითოეულ პორტთან, რათა დატესტოთ კომპონენტი იზოლაციაში.

Hexagonal Architecture-ის განსაზღვრებისთვის იხილეთ:  
[https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)


შემდეგი [[The Hidden Fourth Object the Configurator]]

