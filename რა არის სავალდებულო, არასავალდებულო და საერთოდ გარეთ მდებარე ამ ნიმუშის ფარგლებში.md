

რომ გამოიყენო პატერნი სწორად, საჭიროა ზუსტად იცოდე:

- რა შედის თავად პატერნის ფარგალში,
    
- რა **არ არის მისი ნაწილი**, მაგრამ **სასარგებლოა**,
    
- და რა საერთოდ **არ ეკუთვნის** ამ პატერნს.



### რა არის **სავალდებულო** პატერნისთვის

პატერნის გამოყენება მოითხოვს შემდეგს:

1. აპი **განსაზღვრავს მოცემულ ან მოთხოვნილ ინტერფეისს** ყველა გარე ინტერაქციისთვის.
    
2. აპი აღწერს:
    
    - **მმართავ პორტებს** (driving ports) მოცემული ინტერფეისებისთვის
        
    - **მართულ პორტებს** (driven ports) მოთხოვნილი ინტერფეისებისთვის.  
        (ენებში, სადაც ინტერფეისების დეკლარირება სავალდებულო არ არის, ისინი შეიძლება არ ჩანდეს კოდში პირდაპირ.)
        
3. აპს უნდა შეეძლოს **მართული აქტორების კონფიგურაცია გაშვების დროს** (runtime).
    
4. აპი **არ უნდა იყოს დამოკიდებული კოდით** არც ერთ მმართავ ან მართულ აქტორზე.
    
5. გარე აქტორებს შეუძლიათ კომუნიკაცია **მხოლოდ განსაზღვრული პორტების მეშვეობით**.  
    მათ არ აქვთ წვდომა აპის შიგნით, ე.წ. "ჰექზაგონის" შიგნით მყოფ კოდზე.
    
6. პორტები და ინტერფეისები არა მხოლოდ **ტექნოლოგიურად ნეიტრალური** უნდა იყოს,  
    არამედ **გამოიყენებენ მხოლოდ დომენური/ბიზნესის ტერმინოლოგიას**.



### სასარგებლო რჩევები, მაგრამ **არ არის სავალდებულო**

ეს რჩევები ნიმუშში არ არის ჩაშლილი, მაგრამ მათი გამოყენება მნიშვნელოვნად გაგიადვილებს ცხოვრებას:

1. პატერნი **არ ადგენს**, როგორ უნდა განხორციელდეს კონფიგურატორი.  
    თუმცა, წიგნში მოცემულია ამის მაგალითები  გადახედვა ღირს.
    
2. პატერნი **არ განსაზღვრავს**, როგორ დაარქვა პორტებს სახელი.  
    ჩვენ ვურჩევთ სახელების სქემას `"For doing something"`,  
    რაც უკეთ ხსნის, რატომ არის კონკრეტული ინტერფეისები ერთ ჯგუფში.
    
3. პატერნი **არ ახსენებს პორტების დეტალიზაციას** — ანუ რამდენი ფუნქცია უნდა იყოს ერთ პორტში.  
    პრაქტიკაში უმჯობესია თავიდან იყოს:
    
    - ერთი პორტი თითო მმართავ აქტორზე
        
    - ერთი პორტი თითო მართულ აქტორზე  
        რადგან ეს ინტენციის მიხედვით ასახავს კომუნიკაციას.
        
4. პატერნი **არ განსაზღვრავს, როგორ დაალაგო კოდის სტრუქტურა**.  
    ჩვენ გირჩევთ შემდეგს, რომ კოდი ადვილად წასაკითხი და არქიტექტურულად მკაფიო იყოს:
    
    - გააკეთე ორი პორტის საქაღალდე:  
        **"Driving Ports"** და **"Driven Ports"** — ისინი იყოს `app` საქაღალდესთან ერთად, რადგან პორტები აპის ნაწილია.
        
    - გააკეთე ორი ადაპტერის საქაღალდე:  
        **"Driving Adapters"** და **"Driven Adapters"** — ისინი `app`-ისგან გამოყოფილ სივრცეში მოათავსე.
        
5. პატერნი არ ამბობს, უნდა ჰქონდეთ თუ არა ადაპტერებს ერთმანეთთან პირდაპირი ინტერაქცია.  
    ჩვეულებრივ (გარდა ტესტების შემთხვევისა), **მმართავი ადაპტერი არ ეხება მართულს**.  
    თუმცა, შეიძლება იშვიათი გამონაკლისები არსებობდეს.
    
6. პატერნი პირდაპირ არ გამორიცხავს, რომ **Ports & Adapters-ის ქვესისტემა** არსებობდეს  
    უფრო დიდი **Ports & Adapters სისტემის** შიგნით.
    
    თუ ამ ნიმუშს განვიხილავთ როგორც **Component + Strategy** ნიმუშის სპეციფიკურ შემთხვევას,  
    მაშინ შესაძლებელი ხდება, რომ:
    
    - ეს ქვესისტემა იყოს კონფიგურირებადი სხვადასხვა მართულ აქტორებზე
        
    - სრულად ტესტირებული იყოს იზოლაციაში, ძირითადი სისტემისგან დამოუკიდებლად  
        (იხ. [[Component + Strategy generalizes Ports & Adapters]])
        
    
    თუმცა პრაქტიკაში ეს იშვიათია, ამიტომაც ვამბობთ:
    
    > ნიმუში **არ არის რეკომენდებული ჩაშენებულად (nested)**.  
    > იხ. _"[[ჩაშენებული ჰექსაგონი Nested Hexagons]]" 
    


### რა **არ ეკუთვნის საერთოდ** ამ ნიმუშს

ნიმუშს **არავითარი შეზღუდვა არ აქვს** იმაზე, როგორ მოაწყობ აპის **შიდა სტრუქტურას**.  
შეგიძლია გამოიყენო:

- Domain Driven Design (DDD), ან არა,
    
- განაცალკებო ფუნქცია მოდელისგან, ან არა,
    
- ან თუნდაც შექმნა "ბინძური ბურთი" (Big Ball of Mud).
    

ეს **სწორედ იმით განსხვავდება** Clean Architecture-ისგან ან Onion Architecture-ისგან.  
იხ. თავი 5.5:[[ _Layered, Onion, Clean, Hexagonal: What is the Difference?]]



### სუსტი vs ძლიერი შესაბამისობა ნიმუშთან

შეგიძლია ნიმუში ტექნიკურად სწორად დააიმპლემენტო, მაგრამ **სუსტი შესაბამისობით**.  
მაგალითად, თუ იცი, რომ მონაცემთა ბაზა მაინც SQL-ი იქნება,  
შეიძლება გამოხატო მართული პორტი SQL-ის ტერმინებით —  
ამით ტექნიკურად არ არღვევ ნიმუშს, მაგრამ მაინც აბამ სისტემას SQL-ზე,  
რაც ეწინააღმდეგება ნიმუშის იდეას.


### ძლიერი რეალიზაციისთვის

აპმა **არ უნდა იცოდეს არაფერი გარე ტექნოლოგიაზე**.

მართული პორტი უნდა იყოს **სრულიად აპის ენაზე/დომენზე დაფუძნებული** —  
ის **არც კი უნდა მოიხსენიოს**, რომ არსებობს მონაცემთა ბაზა 
არათუ SQL-ის ტიპის.


|მიზანი|ინტერფეისის სახელი|მაგალითი მეთოდით|
|---|---|---|
|შეკვეთის შენახვა|`OrderStorage`|`void save(Order order)`|
|მომხმარებლის წაკითხვა|`CustomerRetrieval`|`Customer getById(CustomerId id)`|
|გადახდის შესრულება|`PaymentProcessor`|`Receipt process(PaymentInfo info)`|
|შეტყობინების გაგზავნა|`NotificationSender`|`void send(Notification message)`|
|ინვენტარის შემოწმება|`InventoryChecker`|`boolean isInStock(ProductId id)`|


**დააფიქსირე**: ამ პორტებში **არც ერთია არ მოიხსენიებს**:

- SQL-ს
    
- REST-ს
    
- RabbitMQ-ს
    
- ფაილურ სისტემას
    
- კონკრეტულ DTO-ს


### როგორ შეგიძლია დაასათაურო პორტი

შეგიძლია მიმართო Naming Pattern-ს:

forDoingSomething

interface ForRetrievingCustomer {}
interface ForStoringOrders {}
interface ForSendingNotifications {}
