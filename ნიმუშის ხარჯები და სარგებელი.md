**Ports & Adapters** არქიტექტურას  რომელიც ასევე ცნობილია, როგორც **ჰექსაგონალური არქიტექტურა**  თან ახლავს მრავალი სარგებელი კოდის სტრუქტურირების თვალსაზრისით:

#### **სარგებელი**

1. **ტესტირება:**  
    შეგიძლიათ დაწეროთ და გაუშვათ სისტემური დონის ტესტები **პროდაქშენის კავშირების გარეშე**, რაც ტესტებს ხდის სუფთად და სწრაფად.
    
2. **ტესტირების მოქნილობა:**  
    შეგიძლიათ **შეცვალოთ პროდაქშენის კავშირები ტესტურით**, და პირიქით — **ნებისმიერი ტიპის კავშირისთვის** (შეყვანისაც და გამოტანისაც), სისტემის გადაკომპილირების გარეშე.
    
3. **გადაფარებისგან დაცვა (Leakage protection):**  
    აპლიკაციის გარშემო არსებული ტესტური „კედელი“ გეხმარებათ ამოავლენოთ, **როდესაც UI-ის დეტალები ან ტექნოლოგიური ასპექტები შედის ბიზნეს ლოგიკაში**, ან **ბიზნეს ლოგიკა ჟონავს UI-ს ან გარე ტექნოლოგიურ ნაწილში**.
    
4. **დიდი სისტემების იზოლაცია:**  
    სხვადასხვა გუნდს შეუძლია დამოუკიდებლად განავითაროს თავისი კოდის ნაწილი, **ცალკე ტესტოს**, და შემდეგ დააკავშიროს ისინი **დამოწმებული ინტერფეისების მიხედვით**.
    
5. **გრძელვადიანი სისტემები:**  
    შესაძლებელია **ერთი გარე კავშირის ჩანაცვლება მეორით**, როცა დროთა განმავლობაში იცვლება ტექნოლოგია ან ბიზნეს საჭიროებები.
    
6. **დომენზე ორიენტირებული დიზაინი (DDD):**  
    როგორც კი ტექნოლოგიური ელემენტები აპლიკაციის ფარგლებს გარეთ მოექცევა, თქვენ შეგიძლიათ **სრულად კონცენტრირდეთ დომენის მოდელირებაზე** ტექნიკური დეტალებით გაწყვეტის გარეშე.


#### **ხარჯები (რთულობები)**

ამ სტრუქტურის დანერგვას თან ახლავს გარკვეული სირთულე, განსაკუთრებით **ტიპიზირებულ ენებში** (მაგ., Java, C#) — უფრო მეტად, ვიდრე **დინამიკურსა და ტიპ-ინფერენციულ ენებში** (მაგ., Python, Kotlin):

1. მოგიწევთ დაამატოთ **ცვლადი (instance variable)** თითოეული მართული აქტორის (driven actor) შესანახად, ან **ყოველ ჯერზე გამოძახოთ ის**, როცა დაგჭირდებათ.
    
2. მოგიწევთ თითოეული აქტორისთვის დაამატოთ ან **კონსტრუქტორის პარამეტრი**, ან **სეტერი**, ან **კონფიგურატორის გამოძახება**, რათა შესაბამისი ობიექტი მოიპოვოთ.
    
3. აუცილებელია **კონფიგურატორის დაგეგმვა და იმპლემენტაცია**.
    
4. **ტიპიზირებულ ენებში** საჭიროა ყველა აუცილებელი **ინტერფეისის დეკლარირება** (იხილეთ [[ნიმუშის ელემენტები]]: აპები, პორტები, აქტორები, ადაპტერები).
    
5. ასევე, დაგჭირდებათ დამატებითი **საქაღალდეების სტრუქტურა პორტების დეკლარირებისთვის**.

#### **როგორ დავაბალანსოთ ხარჯი და სარგებელი?**

ვინც არასოდეს დაზარალებულა ტექნოლოგიის შეცვლით, ინტერფეისების გადაწევით, ბიზნეს ლოგიკის გაჟონვით, გარე ტექნოლოგიის დეტალების შიდა კოდში მოხვედრით, ან ტესტსა და პროდაქშენს შორის გადართვისას სისტემის გადაკომპილირების საჭიროებით — მათთვის ამ ნიმუშის დანერგვის ხარჯები შეიძლება **გაუმართლებლად დიდად** ჩანდეს.

მაგრამ გამოცდილება აჩვენებს, რომ როგორც კი პროექტი ტკივილს გაყენებს,  
**პატარა რამეები  ინტერფეისების დამატება და ინსტანს ცვლადების მართვა — ამად ნამდვილად ღირს**.