### მარცხენა-მარჯვენა ასიმეტრია

Ports & Adapters პატერნი განზრახ არის დაწერილი იმ პრეტენზიით, რომ ყველა პორტი ძირითადად მსგავსია. ეს პრეტენზია გამოსადეგია არქიტექტურის დონეზე. იმპლემენტაციისას, Ports & Adapters გამოჩნდება ორ ვარიანტში, რომლებსაც აქ ვუწოდებ **primary** (ძირითადი) და **secondary** (მეორადი). ასევე შეგვიძლია ვუწოდოთ **driving adapters** და **driven adapters** — როგორც მალე გახდება ცხადი.

მცოდნე მკითხველმა შეამჩნია, რომ ყველა მოყვანილ მაგალითში FIT ფიქსტურები გამოყენებულია მარცხენა პორტებზე, ხოლო mock-ები მარჯვენა მხარეს. სამ-ფენოვან არქიტექტურაში, FIT ზემოთა ფენაშია მოთავსებული, ხოლო mock ქვედაში.

ეს უკავშირდება use case-ებიდან ცნობილ იდეას: „ძირითადი მსახიობები“ და „მეორადი მსახიობები“. ძირითადი მსახიობია ის, ვინც აპლიკაციას მართავს (იყენებს მას პასიურ მდგომარეობიდან გამოსაყვანად, რათა შეასრულოს მისი ფუნქცია). მეორადი მსახიობი არის ის, ვისაც აპლიკაცია მართავს — ან პასუხის მისაღებად, ან მხოლოდ ინფორმაციის გადასაცემად. განსხვავება ამ ორს შორის ის არის, ვინ არის ინიციატორი ან მმართველი კომუნიკაციის.

ტესტირების ბუნებრივი ადაპტერი ძირითადი მსახიობისთვის არის FIT, რადგან ის განკუთვნილია სკრიპტით აპლიკაციის მართვისთვის. ხოლო მეორადი მსახიობისთვის (მაგალითად, ბაზა) ბუნებრივი ადაპტერია mock, რომელიც პასუხობს მოთხოვნებზე ან იწერს მოვლენებს აპლიკაციიდან.

ამ დაკვირვებების საფუძველზე, სასურველია სისტემის Use Case კონტექსტური დიაგრამის მიყოლა და ძირითადი პორტები და ადაპტერები განთავსდეს ჰექსაგონის მარცხენა (ან ზედა) მხარეს, ხოლო მეორადები — მარჯვენა (ან ქვედა) მხარეს.

ძირითადი და მეორადი ადაპტერების შესაბამისობა FIT-სა და mock-ებთან სასარგებლოა დასამახსოვრებლად, მაგრამ არ უნდა ვეცადოთ ამის მიხედვით შევამციროთ არქიტექტურული გააზრება. Ports & Adapters პატერნის მთავარი სარგებელია ის, რომ შეგვიძლია აპლიკაცია სრულად იზოლირებულ რეჟიმში ვამუშაოთ.


### Use Case-ები და აპლიკაციის საზღვარი

Ports & Adapters პატერნის გამოყენება ეფექტურია Use Case-ების სწორი წერის სტილის დასამკვიდრებლად.

ჩვეულებრივ შეცდომად ითვლება ის, როცა Use Case-ი შეიცავს დეტალურ ცოდნას პორტის მიღმა არსებულ ტექნოლოგიაზე. ასეთ Use Case-ებს ინდუსტრიაში დამსახურებულად აქვთ ცუდი რეპუტაცია — ისინი დიდია, რთულად წასაკითხი, მოსაწყენი, მყიფე და ძვირი შესანარჩუნებლად.

Ports & Adapters არქიტექტურის გააზრება გვეხმარება გავიაზროთ, რომ Use Case-ები უმეტესად უნდა დაიწეროს აპლიკაციის საზღვარზე (შიდა ჰექსაგონზე) — ანუ, უნდა აღწერდეს იმ ფუნქციებსა და მოვლენებს, რასაც აპლიკაცია უჭერს მხარს, გარე ტექნოლოგიების გაუთვალისწინებლად.

ასეთი Use Case-ები უფრო მოკლეა, მარტივად წასაკითხია, იაფია შესანარჩუნებლად და დროში უფრო სტაბილურია.

---

### რამდენი პორტი?

რა არის პორტი (და რა არ არის) — ეს მეტწილად გემოვნების საკითხია. ერთ უკიდურესობაში შეიძლება თითოეულ Use Case-ს საკუთარი პორტი მივანიჭოთ, რაც ასეულობით პორტს გამოიწვევს. მეორე უკიდურესობაში, შეგვიძლია ყველა primary და ყველა secondary პორტი გავაერთიანოთ, დარჩეს მხოლოდ ორი: მარცხენა და მარჯვენა.

არც ერთი უკიდურესობა ოპტიმალური არ ჩანს.

მაგალითად:

- ამინდის სისტემას (რაც _Known Uses_-შია აღწერილი) აქვს ოთხი ბუნებრივი პორტი: ამინდის feed, ადმინისტრატორი, შეტყობინებული აბონენტები, აბონენტების ბაზა.
    
- ყავის მანქანის კონტროლერს აქვს ოთხი პორტი: მომხმარებელი, ბაზა (რეცეპტებითა და ფასებით), დისპენსერები და მონეტების ყუთი.
    
- საავადმყოფოს მედიკამენტების სისტემას შესაძლოა ჰქონდეს სამი: მედდა, რეცეპტების ბაზა, და მედიკამენტების დისპენსერის კომპიუტერული კონტროლი.
    

როგორც ჩანს, „არასწორი“ რაოდენობის პორტის არჩევა სერიოზულ ზიანს არ იწვევს — ეს რჩება ინტუიციური გადაწყვეტილების საგნად.

პირადად მე ვამჯობინებ ორი, სამი ან ოთხი პორტის მოდელს, როგორც აქ და _Known Uses_-შია აღწერილი.



## ცნობილი გამოყენებები

![[Pasted image 20250711224940.png]]

სურათი ასახავს აპლიკაციას, რომელსაც აქვს ოთხი პორტი და თითოეულ პორტზე რამდენიმე ადაპტერი. ეს მოდელი ამოქაჩულია აპლიკაციიდან, რომელიც იღებდა სიგნალებს ეროვნული მეტეოროლოგიური სამსახურისგან მიწისძვრის, ტორნადოს, ხანძრების და წყალდიდობების შესახებ და უტყობინებდა ადამიანებს ტელეფონებზე ან ტელეფონის პასუხის მანქანებზე.

ამ სისტემის განხილვის დროს, სისტემის ინტერფეისები იდენტიფიცირებული იყო და განხილული იყო ტექნოლოგიის მიხედვით, დაკავშირებული მათი მიზნებით. იყო ინტერფეისი, რომელიც იღებდა დამტვრევიან (trigger) მონაცემებს ვაიერიდან (wire feed), ერთი ინტერფეისი შეტყობინებების გასაგზავნად პასუხის მანქანებზე, ადმინისტრაციული ინტერფეისი GUI-ში, და მონაცემთა ბაზის ინტერფეისი აბონენტების მონაცემების მისაღებად.

ადამიანები რთულად უწევდათ საქმე, რადგან მათ სჭირდებოდათ მეტეოროლოგიური სამსახურის HP ინტერფეისის დამატება, ელფოსტით შეტყობინებების გაგზავნა აბონენტებზე და ასევე უნდა მოეხდინათ მათი მზარდი აპლიკაციების პაკეტის დაყოფა და გაერთიანება სხვადასხვა მომხმარებლის შეძენის პრეფერენციების მიხედვით.

შეშფოთებული იყვნენ, რომ მათ ელოდათ მოვლა-შემოწმების კოშმარი, რადგან უნდა შეექმნათ, დაემტვრიათ და შეენარჩუნებინათ სხვადასხვა ვერსიები ყველა კომბინაციისა და ვარიანტისთვის.

მათ გადახვევა დიზაინში იყო სისტემის ინტერფეისების არქიტექტურის მიზნობრივად მოწყობა ტექნოლოგიის ნაცვლად და ტექნოლოგიების შესაძლებელი ჩანაცვლება (ყველა მხრიდან) ადაპტერების საშუალებით.

მათ დაუყოვნებლივ მიიღეს შესაძლებლობა მიეღოთ HP feed და ელფოსტის შეტყობინებები (ახალი ადაპტერები გამოსახულია ნახაზზე წერტილოვანი ხაზებით). თითოეული აპლიკაცია API-ების საშუალებით შეიქმნა ისეთი, რომ შეეძლოთ მასთან headless რეჟიმში მუშაობა, რაც მათ საშუალებას აძლევდა დაამატონ აპლიკაცია-დან-აპლიკაციამდე ადაპტერი და გაეყვანათ აპლიკაციების პაკეტი, საჭიროებისამებრ დააკავშირონ აპლიკაციები.

დასასრულ, როდესაც თითოეული აპლიკაცია სრულად იზოლირებულად მუშაობდა, ტესტირების და mock ადაპტერების საშუალებით, მათ მიიღეს შესაძლებლობა განეხორციელებინათ რეგრესიული ტესტირება დამოუკიდებელი ავტომატიზირებული ტესტ სკრიპტებით.