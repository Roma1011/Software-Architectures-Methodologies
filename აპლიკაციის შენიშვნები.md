### მარცხენა-მარჯვენა ასიმეტრია

Ports & Adapters პატერნი განზრახ არის დაწერილი იმ პრეტენზიით, რომ ყველა პორტი ძირითადად მსგავსია. ეს პრეტენზია გამოსადეგია არქიტექტურის დონეზე. იმპლემენტაციისას, Ports & Adapters გამოჩნდება ორ ვარიანტში, რომლებსაც აქ ვუწოდებ **primary** (ძირითადი) და **secondary** (მეორადი). ასევე შეგვიძლია ვუწოდოთ **driving adapters** და **driven adapters** — როგორც მალე გახდება ცხადი.

მცოდნე მკითხველმა შეამჩნია, რომ ყველა მოყვანილ მაგალითში FIT ფიქსტურები გამოყენებულია მარცხენა პორტებზე, ხოლო mock-ები მარჯვენა მხარეს. სამ-ფენოვან არქიტექტურაში, FIT ზემოთა ფენაშია მოთავსებული, ხოლო mock ქვედაში.

ეს უკავშირდება use case-ებიდან ცნობილ იდეას: „ძირითადი მსახიობები“ და „მეორადი მსახიობები“. ძირითადი მსახიობია ის, ვინც აპლიკაციას მართავს (იყენებს მას პასიურ მდგომარეობიდან გამოსაყვანად, რათა შეასრულოს მისი ფუნქცია). მეორადი მსახიობი არის ის, ვისაც აპლიკაცია მართავს — ან პასუხის მისაღებად, ან მხოლოდ ინფორმაციის გადასაცემად. განსხვავება ამ ორს შორის ის არის, ვინ არის ინიციატორი ან მმართველი კომუნიკაციის.

ტესტირების ბუნებრივი ადაპტერი ძირითადი მსახიობისთვის არის FIT, რადგან ის განკუთვნილია სკრიპტით აპლიკაციის მართვისთვის. ხოლო მეორადი მსახიობისთვის (მაგალითად, ბაზა) ბუნებრივი ადაპტერია mock, რომელიც პასუხობს მოთხოვნებზე ან იწერს მოვლენებს აპლიკაციიდან.

ამ დაკვირვებების საფუძველზე, სასურველია სისტემის Use Case კონტექსტური დიაგრამის მიყოლა და ძირითადი პორტები და ადაპტერები განთავსდეს ჰექსაგონის მარცხენა (ან ზედა) მხარეს, ხოლო მეორადები — მარჯვენა (ან ქვედა) მხარეს.

ძირითადი და მეორადი ადაპტერების შესაბამისობა FIT-სა და mock-ებთან სასარგებლოა დასამახსოვრებლად, მაგრამ არ უნდა ვეცადოთ ამის მიხედვით შევამციროთ არქიტექტურული გააზრება. Ports & Adapters პატერნის მთავარი სარგებელია ის, რომ შეგვიძლია აპლიკაცია სრულად იზოლირებულ რეჟიმში ვამუშაოთ.


### Use Case-ები და აპლიკაციის საზღვარი

Ports & Adapters პატერნის გამოყენება ეფექტურია Use Case-ების სწორი წერის სტილის დასამკვიდრებლად.

ჩვეულებრივ შეცდომად ითვლება ის, როცა Use Case-ი შეიცავს დეტალურ ცოდნას პორტის მიღმა არსებულ ტექნოლოგიაზე. ასეთ Use Case-ებს ინდუსტრიაში დამსახურებულად აქვთ ცუდი რეპუტაცია — ისინი დიდია, რთულად წასაკითხი, მოსაწყენი, მყიფე და ძვირი შესანარჩუნებლად.

Ports & Adapters არქიტექტურის გააზრება გვეხმარება გავიაზროთ, რომ Use Case-ები უმეტესად უნდა დაიწეროს აპლიკაციის საზღვარზე (შიდა ჰექსაგონზე) — ანუ, უნდა აღწერდეს იმ ფუნქციებსა და მოვლენებს, რასაც აპლიკაცია უჭერს მხარს, გარე ტექნოლოგიების გაუთვალისწინებლად.

ასეთი Use Case-ები უფრო მოკლეა, მარტივად წასაკითხია, იაფია შესანარჩუნებლად და დროში უფრო სტაბილურია.

---

### რამდენი პორტი?

რა არის პორტი (და რა არ არის) — ეს მეტწილად გემოვნების საკითხია. ერთ უკიდურესობაში შეიძლება თითოეულ Use Case-ს საკუთარი პორტი მივანიჭოთ, რაც ასეულობით პორტს გამოიწვევს. მეორე უკიდურესობაში, შეგვიძლია ყველა primary და ყველა secondary პორტი გავაერთიანოთ, დარჩეს მხოლოდ ორი: მარცხენა და მარჯვენა.

არც ერთი უკიდურესობა ოპტიმალური არ ჩანს.

მაგალითად:

- ამინდის სისტემას (რაც _Known Uses_-შია აღწერილი) აქვს ოთხი ბუნებრივი პორტი: ამინდის feed, ადმინისტრატორი, შეტყობინებული აბონენტები, აბონენტების ბაზა.
    
- ყავის მანქანის კონტროლერს აქვს ოთხი პორტი: მომხმარებელი, ბაზა (რეცეპტებითა და ფასებით), დისპენსერები და მონეტების ყუთი.
    
- საავადმყოფოს მედიკამენტების სისტემას შესაძლოა ჰქონდეს სამი: მედდა, რეცეპტების ბაზა, და მედიკამენტების დისპენსერის კომპიუტერული კონტროლი.
    

როგორც ჩანს, „არასწორი“ რაოდენობის პორტის არჩევა სერიოზულ ზიანს არ იწვევს — ეს რჩება ინტუიციური გადაწყვეტილების საგნად.

პირადად მე ვამჯობინებ ორი, სამი ან ოთხი პორტის მოდელს, როგორც აქ და _Known Uses_-შია აღწერილი.



## ცნობილი გამოყენებები

![[Pasted image 20250711224940.png]]

სურათი ასახავს აპლიკაციას, რომელსაც აქვს ოთხი პორტი და თითოეულ პორტზე რამდენიმე ადაპტერი. ეს მოდელი ამოქაჩულია აპლიკაციიდან, რომელიც იღებდა სიგნალებს ეროვნული მეტეოროლოგიური სამსახურისგან მიწისძვრის, ტორნადოს, ხანძრების და წყალდიდობების შესახებ და უტყობინებდა ადამიანებს ტელეფონებზე ან ტელეფონის პასუხის მანქანებზე.

ამ სისტემის განხილვის დროს, სისტემის ინტერფეისები იდენტიფიცირებული იყო და განხილული იყო ტექნოლოგიის მიხედვით, დაკავშირებული მათი მიზნებით. იყო ინტერფეისი, რომელიც იღებდა დამტვრევიან (trigger) მონაცემებს ვაიერიდან (wire feed), ერთი ინტერფეისი შეტყობინებების გასაგზავნად პასუხის მანქანებზე, ადმინისტრაციული ინტერფეისი GUI-ში, და მონაცემთა ბაზის ინტერფეისი აბონენტების მონაცემების მისაღებად.

ადამიანები რთულად უწევდათ საქმე, რადგან მათ სჭირდებოდათ მეტეოროლოგიური სამსახურის HP ინტერფეისის დამატება, ელფოსტით შეტყობინებების გაგზავნა აბონენტებზე და ასევე უნდა მოეხდინათ მათი მზარდი აპლიკაციების პაკეტის დაყოფა და გაერთიანება სხვადასხვა მომხმარებლის შეძენის პრეფერენციების მიხედვით.

შეშფოთებული იყვნენ, რომ მათ ელოდათ მოვლა-შემოწმების კოშმარი, რადგან უნდა შეექმნათ, დაემტვრიათ და შეენარჩუნებინათ სხვადასხვა ვერსიები ყველა კომბინაციისა და ვარიანტისთვის.

მათ გადახვევა დიზაინში იყო სისტემის ინტერფეისების არქიტექტურის მიზნობრივად მოწყობა ტექნოლოგიის ნაცვლად და ტექნოლოგიების შესაძლებელი ჩანაცვლება (ყველა მხრიდან) ადაპტერების საშუალებით.

მათ დაუყოვნებლივ მიიღეს შესაძლებლობა მიეღოთ HP feed და ელფოსტის შეტყობინებები (ახალი ადაპტერები გამოსახულია ნახაზზე წერტილოვანი ხაზებით). თითოეული აპლიკაცია API-ების საშუალებით შეიქმნა ისეთი, რომ შეეძლოთ მასთან headless რეჟიმში მუშაობა, რაც მათ საშუალებას აძლევდა დაამატონ აპლიკაცია-დან-აპლიკაციამდე ადაპტერი და გაეყვანათ აპლიკაციების პაკეტი, საჭიროებისამებრ დააკავშირონ აპლიკაციები.

დასასრულ, როდესაც თითოეული აპლიკაცია სრულად იზოლირებულად მუშაობდა, ტესტირების და mock ადაპტერების საშუალებით, მათ მიიღეს შესაძლებლობა განეხორციელებინათ რეგრესიული ტესტირება დამოუკიდებელი ავტომატიზირებული ტესტ სკრიპტებით.


## Mac, Windows, Google, Flickr, Web 2.0

1990-იანების დასაწყისში, MacIntosh აპლიკაციებს, როგორიცაა ტექსტური რედაქტორები, მოეთხოვებოდა API-ებით მართვადი ინტერფეისები, რათა აპლიკაციებსა და მომხმარებლის დაწერილ სკრიპტებს შეეძლოთ აპლიკაციის ყველა ფუნქციის გამოყენება. Windows-ის დესკტოპ აპლიკაციებმა იგივე შესაძლებლობა მიიღეს (მე არ მაქვს ისტორიული ცოდნა რომელმა ადრე მიიღო ეს, და ეს ამ საკითხში მთავარ როლს არ თამაშობს).

დღევანდელი (2005 წ.) ვებ აპლიკაციების ტენდენციაა API-ების გამოქვეყნება და სხვა ვებ აპლიკაციების პირდაპირი წვდომის უზრუნველყოფა ამ API-ებზე. მაგალითად, შესაძლებელია გამოაქვეყნო ადგილობრივი კრიმინალური მონაცემები Google რუკაზე, ან შექმნა ვებ აპლიკაციები, რომლებიც იყენებენ Flickr-ის ფოტოარქივირების და ანოტაციის შესაძლებლობებს.

ამ ყველა მაგალითში მთავარი პორტების API-ების გამოჩენა ხდება. ამ ტექსტში არაფერია საუბარი მეორად პორტებზე.

---

## შენახული შედეგები

ეს მაგალითი, რომელსაც წერდა ვილემ ბოღარეცი C2 ვიკიზე:

"მე შევხვდი მსგავს სიტუაციას, მაგრამ ძირითადად იმიტომ, რომ ჩემი აპლიკაციის შრე ხშირად იქცეოდა როგორც სატელეფონო გადამრთველი, რომელიც მართავდა იმ პროცესებს, რაც არ უნდა ეხელმძღვანელა. ჩემი აპლიკაცია ქმნიდა შედეგს, აჩვენებდა მომხმარებელს და შემდეგ ჰქონდა შესაძლებლობა ეს შედეგი შეენახა.

ჩემი მთავარი პრობლემა იყო ის, რომ საჭირო არ იყო ამ შედეგის მუდმივად შენახვა. ამიტომ, აპლიკაცია ქმნიდა შედეგს, მას ატვირთავდა ბუფერში და აჩვენებდა მომხმარებელს. შემდეგ, როცა მომხმარებელი გადაწყვეტდა შედეგის შენახვას, აპლიკაცია იღებდა ბუფერს და მართლა შეინახავდა მას.

ეს მე არ მომწონდა. შემდეგ მოვიფიქრე გამოსავალი: მქონდეს პრეზენტაციის კონტროლი შენახვის შესაძლებლობებით. ახლა აპლიკაცია აღარ ატარებს შედეგს სხვადასხვა მიმართულებით, არამედ უბრალოდ გამოაქვთ იგი პრეზენტაციის კონტროლზე. პრეზენტაციის კონტროლი არის ის, ვინც ბუფერს ინახავს და მომხმარებელს აძლევს შესაძლებლობას დაარქივოს შედეგი.

ტრადიციული ფენოვანი არქიტექტურა განასხვავებს "UI"-ს და "შენახვას" როგორც სხვადასხვა კომპონენტებს. Ports & Adapters არქიტექტურა კი შეუძლია შეამციროს გამოსავალი მხოლოდ "გამოსვლად"."

---

## ანონიმური მაგალითი C2 ვიკიზე

"ერთ პროექტში, სადაც ვმუშაობდი, ვიყენებდით კომპონენტური სტერეოსისტემის სისტემატიკურ მეტაფორას. თითოეულ კომპონენტს აქვს განსაზღვრული ინტერფეისები, თითოეულს თავისი კონკრეტული მიზანი. ჩვენ შეგვიძლია ვაერთოთ კომპონენტები ერთმანეთთან თითქმის შეუზღუდავი გზებით, გამოყენებით უბრალო კაბელებსა და ადაპტერებს."

---

## განაწილებული, დიდი გუნდის განვითარება

ეს მაგალითი ჯერ კიდევ ტესტირების ეტაპზეა, ამიტომ არ ითვლება სრულფასოვან გამოყენებად არქიტექტურისთვის. თუმცა, საინტერესოა მისი განხილვა.

გუნდები სხვადასხვა ლოკაციებში აგებენ Hexagonal არქიტექტურას, იყენებენ FIT-ს და mock-ებს, რათა აპლიკაციები ან კომპონენტები შეამოწმონ იზოლირებულ რეჟიმში. CruiseControl სისტემის აგება მიდის ნახევარ საათში ერთხელ და აშვებს ყველა აპლიკაციას FIT+mock კომბინაციით. როგორც კი აპლიკაციის ქვესისტემები და მონაცემთა ბაზები მზადდება, mock-ებს ცვლიან ტესტ ან რეალურ მონაცემთა ბაზებზე.

---

## UI-ს და აპლიკაციის ლოგიკის განცალკევება

ეს მაგალითიც ჯერ კიდევ გამოცდების პროცესშია და არ ითვლება სრული გამოყენებად. თუმცა, საინტერესოა.

UI დიზაინი არასტაბილურია, რადგან ჯერ არ არის გადაწყვეტილი მართვის ტექნოლოგია ან მეტაფორა. უკანა პლანზე სერვისების არქიტექტურაც ჯერ არ არის გადაწყვეტილი და, სავარაუდოდ, შეიცვლება რამდენიმე ჯერ მომდევნო ექვს თვეში. მიუხედავად ამისა, პროექტი ოფიციალურად დაწყებულია და დრო გადის.

აპლიკაციის გუნდი ქმნის FIT ტესტებს და mock-ებს, რომ იზოლირებულად შეამოწმოს აპლიკაცია და შექმნას ტესტირებადი, დემონსტრაციული ფუნქციონალობა მომხმარებლისთვის. როდესაც UI და უკანა სერვისების გადაწყვეტილებები საბოლოოდ მიიღება, "მარტივად იქნება" ამ ელემენტების დამატება აპლიკაციაში.

დამატებითი ინფორმაცია მოგვიანებით — ან სცადე შენი თავი და მომწერე შედეგებზე.