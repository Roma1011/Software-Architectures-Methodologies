
#### **აპლიკაცია (Application):**

პროგრამული უზრუნველყოფა, რომლის გარშემოც ვქმნით არქიტექტურულ საზღვარს.  
მოიცავს სრულად ბიზნეს ლოგიკას, **და არ შეიცავს ტექნოლოგიებზე, მონაცემთა ბაზებზე, ქსელებზე, ადამიანებზე ან სხვა გარე კოდზე რაიმე მითითებას**.  
ყველა ტექნოლოგიური კომპონენტი ითვლება **გარე ელემენტად**, მათ შორის ის ადაპტერებიც, რომლებიც ამ აპლიკაციასთან დაკავშირებას უზრუნველყოფს.

**სინონიმები:** აპი, ექსაგონი, სისტემა, SUT (System Under Test), SUD (System Under Development), ბირთვი (Core)


#### **გაფართოებული სისტემა (Extended System):**

აპლიკაციის გარეთ არსებული ეკოსისტემა, რომელიც მოიცავს ადაპტერებსა და უშუალოდ დაკავშირებულ ტექნოლოგიებს  მონაცემთა ბაზები, რეპოზიტორიები, ქსელური ინტერფეისები, GUI და ა.შ.


#### **აქტორი (Actor):**

ყველაფერი, რაც გამოხატავს ქცევას  იქნება ეს აპარატურა, პროგრამული ნაწილი, ადამიანი ან ორგანიზაცია.  
აქტორი ისაა, ვინც შეუძლია _“if”-ის ოპერაციის შესრულება_ ანუ მიიღოს გადაწყვეტილება.


#### **ძირითადი ან მმართავი აქტორი (Primary / Driving Actor):**

აქტორი, რომელიც **თავად იწყებს კომუნიკაციას აპთან**, აგზავნის მოთხოვნას ან ააქტიურებს აპს უძრავი მდგომარეობიდან (quiescent state).  
_“Primary”_ და _“Driving”_ სინონიმებია.  
აქტორი შეიძლება იყოს ერთ სიტუაციაში ძირითადი და მეორეში  მეორეული.


#### **მეორეული ან მართული აქტორი (Secondary / Driven Actor):**

აქტორი, **რომელთანაც აპი თავად იწყებს კომუნიკაციას**, აგზავნის მოთხოვნას ან ამოძრავებს მას.  
მეორეული და მართული სინონიმებია.


#### **ინტერაქტორი (Interactor):**

პროგრამული ელემენტი, რომელიც პირდაპირ პორტთან ურთიერთობს.  
თუ აქტორს ადაპტერი არ სჭირდება პორტთან დასაკავშირებლად  ის თავადაა ინტერაქტორი.  
თუ სჭირდება  ინტერაქტორია ადაპტერი, და აქტორი აღარ არის უშუალო მონაწილე.  
**ინტერაქტორი = აქტორი ან ადაპტერი.**


#### **ინტერფეისი (Interface):**

მეთოდების ნაკრები, რომელიც აღწერს, თუ რა სერვისებს უნდა ითანხმოს ის, ვინც ამ ინტერფეისს იმპლემენტირებს (ასრულებს).

- **მიწოდებული ინტერფეისი (Provided Interface):**  
    აღწერს სერვისებს, რომლებსაც აპი სთავაზობს გარე აქტორებს.  
    იყენებენ მმართავი ინტერაქტორები და იმპლემენტირდება აპის მიერ.  
    ასევე ცნობილია, როგორც **API**.
    
- **მოთხოვნილი ინტერფეისი (Required Interface):**  
    აღწერს სერვისებს, რომლებიც აპს სჭირდება ფუნქციონირებისთვის.  
    აპი იყენებს მას, ხოლო **იმპლემენტირდება მართული ინტერაქტორების მიერ**.  
    დინამიკურ ენებში, სადაც ინტერფეისები არ არის დეკლარირებული, ეს უბრალოდ ნიშნავს ყველა იმ გამოძახებას, რასაც აპი პორტზე გააკეთებს.  
    ასევე ცნობილია როგორც **SPI** (Service Provider Interface).


#### **[[პორტი (Port)]]:**

აპის მიერ განსაზღვრული **მიწოდებული ან მოთხოვნილი ინტერფეისი**.  
პორტი გამოხატავს მიზანმიმართულ კომუნიკაციას აპსა და გარე აქტორს შორის.  
პორტის სახელი აღწერს მიზანს (მაგ., `forPlacingOrders`).

- **ძირითადი / მმართავი პორტი (Primary / Driving Port):**  
    შეიცავს მიწოდებულ ინტერფეისებს, რომელთაც იყენებენ მმართავი ინტერაქტორები აპთან მოთხოვნების გასაგზავნად.  
    ასევე ეწოდება: **Inbound Port**, **API**.
    
- **მეორეული / მართული პორტი (Secondary / Driven Port):**  
    შეიცავს მოთხოვნილ ინტერფეისებს, რომლებსაც აპი იყენებს მართულ ინტერაქტორებთან კომუნიკაციისთვის.  
    ასევე ეწოდება: **Outbound Port**, **SPI**.


#### **ადაპტერი (Adapter):**

კოდი, რომელიც აცდენს ტექნოლოგიაზე დამოკიდებულ ექსტერნალურ აქტორებს აპის ტექნოლოგიურად ნეიტრალურ პორტებთან.  
ადაპტერი გარდაქმნის შეტყობინებებს გარე ფორმატიდან აპისთვის გასაგებ მოთხოვნებად  და პირიქით.

- **ძირითადი / მმართავი ადაპტერი (Primary / Driving Adapter):**  
    აკავშირებს მმართავ აქტორს მმართავ პორტთან.  
    ასევე: **Inbound Adapter**, **API Adapter**.
    
- **მეორეული / მართული ადაპტერი (Secondary / Driven Adapter):**  
    აკავშირებს მართულ აქტორს მართულ პორტთან.  
    ასევე: **Outbound Adapter**, **SPI Adapter**.



### **დასახელების სირთულე**

სახელების შერჩევაზე ბევრი ვიწვალეთ.  
არსებობს სამი ძირითადი ელემენტი: **აქტორი, ადაპტერი და პორტი**, და თითოეულისთვის საჭიროა ორი სახასიათო ზედსართავი.

გავცადეთ სხვადასხვა ვარიანტი:

- _driving / driven_
    
- _primary / secondary_
    
- _inbound / outbound_
    
- _API / SPI_
    
- _left / right_
    

**Preview ვერსიაში გამოვიყენეთ driving / driven და primary / secondary**, თუმცა ზოგიერთმა მკითხველმა აღნიშნა, რომ ამ ტერმინებით რთული იყო ოპერირება და ურჩევნდათ inbound / outbound ან API / SPI.

მხოლოდ **driving / driven** და **primary / secondary** შეიძლება თანაბრად მოერგოს **სამივე ტიპს** — აქტორს, ადაპტერს და პორტს:  
შეგიძლიათ თქვათ:

- driving actor
    
- driving adapter
    
- driving port  
    (იგივე მეორე მხარესაც)
    

მაგრამ არ შეგიძლიათ თქვათ _“inbound actor”_ ან _“API actor”_ — ასეთი ფორმულირება უაზრობაა.

**პირადად ალისტერი სინონიმებზე არ დარდობდა.**  
თუ შენ გირჩევნია inbound / outbound პორტებისა და ადაპტერებისთვის — მშვენიერია.  
პორტების შემთხვევაში, **“API port”** და **“SPI port”** საერთოდ მშვენივრად ჟღერს, რადგან პორტები ინტერფეისებია.

**სადაც inbound/outbound ყველაზე პრაქტიკულია  საქაღალდეების დასახელებაშია.**  
მე არასდროს მომწონდა გვერდიგვერდ განთავსებული ორი საქაღალდე: _Driven Adapters_ და _Driving Adapters_ — ისინი ზედმეტად ჰგავდნენ ერთმანეთს.  
ამის ნაცვლად, **Inbound Adapters** და **Outbound Adapters** ბევრად უფრო მკაფიოა.

ასევე მინახავს დასახელებები როგორიცაა **“Provided/Required”** და **“Controllers/Providers.”**  

შემდეგი [[App პორტები აქტორები ადაპტერები]]