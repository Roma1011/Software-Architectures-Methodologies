# Dependency Injection

წყარო: [https://en.wikipedia.org/wiki/Dependency_injection]  
დეპენდენსი ინჯექშენი არის დიზაინის პატერნი, რომელშიც ობიექტი ან ფუნქცია იღებს სხვა ობიექტებს ან ფუნქციებს, რომლებსაც ის ეყრდნობა... ფუნდამენტურად, დეპენდენსი ინჯექშენი შედგება მეთოდის პარამეტრების გადაცემისგან.  
დეპენდენსი ინჯექშენის დროს კონფიგურატორი ეუბნება გამომგზავნს, რომელ რეცივერს გამოიყენოს.

---

# Dependency Lookup

წყარო: [http://xunitpatterns.com/Dependency%20Lookup.html]  
ჩვენ ვცდილობთ არ ჩავდოთ ჩვენი კოდში კონკრეტული კლასების სახელები, რომელებზე ჩვენ ვდევნებით, რადგან სტატიკური ბინდინგი მკვეთრად ამცირებს ჩვენს შესაძლებლობებს, თუ როგორ შეიძლება პროგრამა დაიფაროს მუშაობის დროს. ამის ნაცვლად, ვაკონკრეტებთ "კომპონენტის ბროკერს", რომელიც გვაბრუნებს მზად გამოყენებადი ობიექტს.  
დეპენდენსი ლუკაპის დროს გამომგზავნი ეკითხება კონფიგურატორს, რომელ რეცივერს გამოიყენოს.  
აქ წერია, რომ გამომგზავნი შეიცავს ბროკერზე ხარვეზიან რეფერენსს, მაგრამ ეს აუცილებელი არაა (იხილეთ [https://springframework.guru/service-locator-pattern-in-spring/] და Known Uses: Avalon). მთავარია ფრაზა "გვაბრუნებს ჩვენთვის გამოყენებად ობიექტს".

---

# განხილვა: Dependency Inversion, Injection, Lookup

Configurable Receiver იყენებს სამივე კონცეფციას: დეპენდენსი ინვერსიას, დეპენდენსი ინჯექშენს და დეპენდენსი ლუკაპს.  
ამ ცნებებით ბევრი ადამიანი იცბუნებს, ამიტომ ეს ნაწილი ასახელებს მათ ურთიერთობებს.  
გარდა ამისა, ინვერსია კონტროლისა ხშირად ცვლადებად აიგივება ამ სამ პატერნთან, თუმცა ეს გაუთვალისწინებელია.

ნაწილობრივ დაბნეულობა გამოწვეულია იმით, რომ "დეპენდენსი" შეიძლება ნიშნავდეს როგორც კომპილაციის, ისე შესრულების დროს დამოკიდებულებას.  
"ინვერსია" ნიშნავს მოქმედების წარღვნის გაკეთებას სხვა, დაუდგენელ მოქმედებაზე.  
ამიტომ დეპენდენსი ინვერსია, ინჯექშენი, ლუკაპი და ინვერსია კონტროლისა ხშირად არასწორად აიგივება.

ეს განხილვა სუბსეტია [https://alistaircockburn.com/Articles/Discussion-of-dependency-injection-etc], სრულად იხილეთ იქ.

---

## Dependency Inversion Principle (კომპილაციის დრო)

დეპენდენსი ინვერსიის პრინციპი ეხება კომპილაციის დროს დამოკიდებულებებს ორ ელემენტს შორის.  
"ინვერსია" ნიშნავს ძველ და დამაჯერებელ იერარქიულ დეკომპოზიციის ტექნიკებს, სადაც აბსტრაქტული გადაწყვეტილებები იერარქიის მაღლა იყო და დამოკიდებული იყვნენ კონკრეტულ იმპლემენტაციებზე, რომლებიც იერარქიის ქვემოთ იმყოფებოდნენ. პრინციპი ამბობს: "გააკეთეთ საპირისპირო."  
ელემენტი A-ს აქვს კომპილაციის დროის დამოკიდებულება ელემენტ B-ზე, თუ A-ს კომპილაციისთვის სჭირდება B-ის არსებობა. თუ B-ის იმპლემენტაცია შეიცვალა, A-ს უნდა გადამკომპილაცია.

**დეპენდენსი ინვერსიის პრინციპი:**

- A. მაღალ დონეზე მოდულები არ უნდა იყვნენ დამოკიდებული დაბალ დონეზე მოდულებზე. ორივე უნდა იყოს დამოკიდებული აბსტრაქციებზე.
    
- B. აბსტრაქციები არ უნდა იყვნენ დამოკიდებული დეტალებზე. დეტალები უნდა იყვნენ დამოკიდებული აბსტრაქციებზე.
    

წყაროები:

- [https://web.archive.org/web/20110714224327/http://www.objectmentor.com/resources/articles/dip.pdf]
    
- [[https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)]
    

Bob Martin-ის ორიგინალური სტატია:  
რატომ ვიყენებ სიტყვა "ინვერსია"? იმიტომ, რომ ტრადიციულად გამოყენებული მეთოდები (მაგ. Structured Analysis and Design) ქმნიდნენ სტრუქტურებს, სადაც მაღალ დონეზე მოდულები იყვნენ დამოკიდებულნი დაბალ დონეზე მოდულებზე, ხოლო აბსტრაქციები - დეტალებზე. მიზანი იყო იერარქიის აღწერა, როგორ აკავშირებდნენ მაღალ დონეზე მოდულები დაბალ დონეზე მოდულებს.  
სტატიის თარიღი: 1996. მაშინ ძირითადად იყენებდნენ სტრუქტურირებულ ანალიზს და დიზაინს. აქ იყო ცნება "მაღალი" და "დაბალი" დონეები იერარქიაში.  
ეს შეიცვალა ობიექტზე ორიენტირებულ ენებში, სადაც იერარქია აღარ არის აშკარა, მაგრამ რჩება აზრი, რომ არსებობს პოლიტიკა ("დაატყობინო ადამიანები, როცა ვითარება შეიცვლება") და სხვადასხვა იმპლემენტაციის შესაძლებლობები (ტელეფონი, გვერდითი ზარები, მეილი).

შედეგად, თუ "მეტი გზა არსებობს ამის გაკეთების" პრინციპი მივიღოთ, მივიღებთ იმას, რასაც Bob Martin "დაბალ დონეს" უწოდებს.  
ამიტომ:

- თუ არსებობს სხვადასხვა გზები ამის გაკეთების,
    
- გამოიყენეთ დიზაინის იდეა.
    

ეს არის Configurable Receiver პატერნის არსი:  
დაწესეთ პოლიტიკის ობიექტის მოთხოვნილი ინტერფეისი, დაამატეთ ინსტანციის ცვლადი რეცივერის შესანახად შესრულების დროს, შექმენით კონფიგურატორი, რომელიც რეცივერს მიუწვდება და გაუშვით.

Bob Martin-ის მაგალითი ღილაკისა, რომელიც controlling lamp-ია:  
ღილაკი უფრო მაღალ დონეზეა თუ ლამპა? არა.  
ღილაკის დაყენება პოლიტიკის გადაწყვეტილებაა? არა. ღილაკი გამოიყენება სხვადასხვა მოწყობილობისთვის (hot tub, რადიო), ამიტომ სხვადასხვა "ჩართვის/გამორთვის" სუბიექტია.

კიდევ ერთი მნიშვნელოვანი კითხვა დიზაინშია: ვინ ფლობს ინტერფეისის განსაზღვრას?  
დიდ პროექტებში ეს შეიძლება იყოს ცალკე მოდული, რომელიც ორივე გუნდს ახვედრებს.

2023 წლის მაისში ვკითხე Bob Martin-ს კომენტარი ტექსტზე:  
ახლა მე განსაზღვრავ დონეს ისე, როგორც Page-Jones დიდი ხნის წინ:  
**შორისობა I/O-სგან.**

დეპენდენსი ინვერსია და Configurable Receiver პატერნი დაკავშირებულია იმით, რომ დეპენდენსი ინვერსია გულისხმობს Required Interface-ის გამოცხადებას, რათა სხვადასხვა რეცივერი გამოიყენოს მინიმალური გადაკომპილაციით. პრინციპი ასახავს დიზაინის მიზეზებს და ინტერფეისის აღწერას, მაგრამ კონფიგურატორზე არაფერს ამბობს.

---

##  Dependency Injection (განსაკუთრებული შესრულების დრო)

წყარო: [https://en.wikipedia.org/wiki/Dependency_injection]  
დეპენდენსი ინჯექშენი არის დიზაინის პატერნი, რომელშიც ობიექტი ან ფუნქცია იღებს სხვა ობიექტებს ან ფუნქციებს, რომლებსაც ის ეყრდნობა... ფუნდამენტურად, დეპენდენსი ინჯექშენი შედგება მეთოდის პარამეტრების გადაცემისგან.  
ელემენტ A-ს აქვს შესრულების დროის დამოკიდებულება ელემენტ B-ზე, თუ ის სჭირდება B-ის არსებობა A-ს გამოძახების დროს. თუ B წაიშლება A-ს გამოძახებამდე, გამოძახება წარუმატებელი იქნება.  
ამ შემთხვევაში, არის მესამე ელემენტი C, რომელიც იცნობს B-ს და გადასცემს მას A-ს, კონსტრუქტორის ან სხვა ინტერფეისის მეშვეობით. A-ს აქვს შესრულების დროის დამოკიდებულება B-ზე. B არ უნდა წაიშალოს ადრე, ვიდრე A მას მიმართავს.  
დეპენდენსი ინჯექშენი არის გზა, რომ A იცნობს B-ს: C ეუბნება ამას A-ს.  
არ არის მითითებული, რა გააკეთებს A B-თან.

---

##  Dependency Lookup (განსაკუთრებული შესრულების დრო)

დეპენდენსი ლუკაპი არის მეორე გზა, რომ A-ს შეიტყოს B-ს ვინაობა შესრულების დროს:  
A ეკითხება მესამე მხარეს C-ს ინფორმაციას.  
წყარო: [http://xunitpatterns.com/Dependency%20Lookup.html]  
... "კომპონენტის ბროკერი", რომელიც გვიბრუნებს მზად გამოსაყენებელ ობიექტს.

ტექსტში ნათქვამია, რომ გამომგზავნი შეიცავს ბროკერზე მკაცრად დაწერილ რეფერენსს, მაგრამ ეს არაა საჭირო. A-ს შეუძლია C-სთან მივიდეს ნებისმიერ სამ გზით: მკაცრად დაწერილი, დეპენდენსი ინჯექშენით ან დეპენდენსი ლუკაპით.

მშვიდად შეიძლება ვთქვათ, რომ A-ს ორი გზა აქვს შეიტყოს B, თუ არ არის მკაცრად დაწერილი:

- A ეკითხება C-ს B-ს შესახებ (დეპენდენსი ლუკაპი)
    
- C ეუბნება A-ს B-ს შესახებ (დეპენდენსი ინჯექშენი)
    

Configurable Receiver პატერნის კონტექსტში, C არის "კონფიგურატორი". მას აქვს ინფორმაცია, რომელი B უნდა გამოიყენოს A-მ.

დეპენდენსი ინჯექშენსაც და დეპენდენსი ლუკაპსაც აინტერესებს მხოლოდ, როგორ მოიპოვოს A-მ B-ს ვინაობა, არ არის მითითებული რა გააკეთოს A-მა შემდეგ.  
ეს მნიშვნელოვანია ინვერსია კონტროლის ანალიზისას.


## ინვერსია კონტროლის (Inversion of Control)

(შესრულების დროის საკითხი)  
ინვერსია კონტროლისა არის შესრულების დროს კონცეფცია, რომელიც არ არის დაკავშირებული აქამდე განხილულ პატერნებთან. იგი ხშირად მცდარად არის წარმოდგენილი. ვიქიპედიის ჩანაწერიც კი განახლდა წინა შეცდომების გამოსასწორებლად [[https://en.wikipedia.org/wiki/Inversion_of_control](https://en.wikipedia.org/wiki/Inversion_of_control)].  
ეს იდეა პირველად საჯაროდ გაიხსნა 1985 წლის სტატიაში, რომელიც აღწერდა Mesa სისტემას, და შეიცავდა ფრაზას „ჰოლივუდის კანონი“ [[https://digibarn.com/friends/curbow/star/XDEPaper.pdf](https://digibarn.com/friends/curbow/star/XDEPaper.pdf)]:  
„არ მოგვწეროთ, ჩვენ დაგირეკავთ“ (ჰოლივუდის კანონი). ინსტრუმენტმა უნდა უზრუნველყოს, რომ Tajo აცნობოს მას, როცა მომხმარებელი რაიმე მოვლენას გაუგზავნის, ვიდრე მისაღები იყოს „მომხმარებლისგან ბრძანების მოთხოვნა და შესრულება“ მოდელი.

„ინვერსია კონტროლისა“ სიტყვა გამოიყენეს 1988 წლის სტატიაში „Designing Reusable Classes“ რალფ ჯონსონისა და ბრაიან ფუტის მიერ:  
მნიშვნელოვანი მახასიათებელია, რომ ფრეიმვორკის მომხმარებლის მიერ განსაზღვრული მეთოდები ხშირად იწერება ფრეიმვორკის შიგნით, მომხმარებლის კოდის ნაცვლად. ფრეიმვორკი ხშირად ასრულებს მთავარ პროგრამის როლს აპლიკაციის აქტივობის კოორდინაციასა და თანმიმდევრობაში. ეს ინვერსია კონტროლისა აძლევს ფრეიმვორკებს შესაძლებლობას იქცნენ გაფართოების უნარიან ჩარჩოებად. მომხმარებლის მიერ მიწოდებული მეთოდები განაახლებენ ფრეიმვორკში განსაზღვრულ ზოგად ალგორითმებს კონკრეტული აპლიკაციისთვის.

აქ ხაზგასმით უნდა ითქვას, რომ ის, რაც მათ აღწერეს, არ ეხება დეპენდენსი ინვერსიას, ინჯექშენს ან ლუკაპს. ეს სრულიად განსხვავებული კონცეფციაა.

ინვერსია კონტროლის დროს ელემენტი A რეგისტრირდება ელემენტ B-თან გარკვეული ინტერესის მისაცემად, ან ინჯექშენის ფრეიმვორკი აკეთებს ამ რეგისტრაციას. შემდეგ, როცა B-ს აქვს საინტერესო ინფორმაცია A-სთვის, B ურეკავს ან უგზავნის შეტყობინებას A-ს.

შენიშნეთ, რომ ეს ყოველთვის არის ორ-საფეხურიანი პროცესი:

1. A რეგისტრირდება ან რეგისტრირდება B-სთან, რომ დააყენოს callback მისამართი.
    
2. როცა B ამჩნევს შესაბამის მოვლენას, ის დარეკავს ამ callback მისამართზე.
    

მნიშვნელოვანი ალტერნატიული სიტყვა იქნებოდა „callback“.

„ინვერსია“, რაც აქ არის ნახსენები, გულისხმობს ჩვეულებრივ ზარს, სადაც A ურეკავს B-ს სერვისისთვის და ზარის კონტროლი A-ს აქვს.

ახალ სიტუაციაში, როცა B-ს აქვს A-ს იდენტიფიკატორი, B აკონტროლებს ზარის დროს და ურეკავს A-ს მნიშვნელოვანი მოვლენის შემთხვევაში. ამიტომაც „ინვერსია კონტროლისა“.

ინვერსია კონტროლის მახასიათებელია ფრეიმვორკების, ბიბლიოთეკებისგან განსხვავებით:

- ბიბლიოთეკის დროს B-ს ელემენტი იწერება, რომ A-ს მიმართოს კონკრეტული დავალების შესასრულებლად.
    
- ფრეიმვორკის დროს B-ს ელემენტი ურეკავს A-ს, რომ სპეციალიზებული ქცევა უზრუნველყოს ფრეიმვორკის დათვისებისთვის.
    

ეს მექანიზმი ფართოდ გამოიყენება UI ფრეიმვორკებში, მოვლენათა სისტემებში და ASP.NET-ში. თითოეულ შემთხვევაში ფრეიმვორკი „აღვიძებს“ ჩვენს ობიექტს, რომ მოაგვაროს რაიმე მოვლენა.

.NET-ის მაგალითი ინვერსია კონტროლის შესახებ (წყარო: „Dependency Injection in .NET“, Mark Seemann):  
ინვერსია კონტროლის ტერმინი თავდაპირველად აღნიშნავდა ნებისმიერ პროგრამირების სტილს, სადაც საერთო ფრეიმვორკი ან შესრულების გარემო აკონტროლებს პროგრამის მართვას. ამ განსაზღვრებით, .NET ფრეიმვორკზე შექმნილი უმეტესობა პროგრამების იყენებს IoC-ს.  
ASP.NET აპლიკაციის დაწერისას ხსნი კავშირს ASP.NET გვერდის სიცოცხლის ციკლთან, მაგრამ მართვა არა შენ გყავს — ASP.NET მართავს.  
WCF სერვისის დაწერისას იმპლემენტირებ ინტერფეისებს ატრიბუტებით. კოდის წერას შენ აკეთებ, მაგრამ კონტროლი არა შენ გყავს — WCF-ია.  
დღეს ჩვეულებრივად გვაქვს ფრეიმვორკებთან მუშაობის ეს მოდელი და ვერც ვგრძნობთ განსაკუთრებულობას, თუმცა ეს განსხვავებულია სრულ კონტროლთან შედარებით.  
ამ ყველაფრისგან განსხვავებით, კომანდ-ლაინ პროგრამებში შენ მართავ Main ფუნქციას და იცი, რომ კონტროლი შენ გყავს — პროგრამის ციკლი და მართვა შენია, არ არსებობს განსაკუთრებული მოვლენები ან გადატვირთული წევრები.

გთავაზობ ნიმუშს „ჩვეულებრივი“ და „ინვერსიული“ კონტროლის ზუსტი განსხვავების:  
თუ შენ წერ Main ფუნქციას, კონტროლი შენ გყავს („ჩვეულებრივი“ კონტროლი).  
თუ ASP.NET აპლიკაციას წერ, ორ საფეხურზე მიდიხარ:

- პირველ რიგში, კავშირს ხსნი ASP.NET გვერდის სიცოცხლის ციკლთან.
    
- შემდეგ ASP.NET იღებს კონტროლს და იძახებს შენს კოდს საჭიროებისას.
    

„ჩვეულებრივი“ კონტროლი და „ინვერსია კონტროლისა“ შეიძლება გამოიყენო ცვლის წესით. მე მიყვარს IoC-ს ჩავთვალო callback-ის დაყენებად, სადაც callback კოდი უბრალოდ აგრძელებს A-სა და B-ს დიალოგს და ავსებს B-ს საჭირო ინფორმაციას.

პატერნის ანალიზისთვის კარგი, მარტივი მაგალითია Observer პატერნი:

- Observer არის A და Subject არის B [https://en.wikipedia.org/wiki/Observer_pattern].
    
- აქ არ არის ელემენტი C, რომელიც წარუდგენს ერთმანეთს. როგორ შეიტყო A-მ B-ის შესახებ, არ არის ინვერსია კონტროლის ნაწილი.
    

ფიგურა 6.31-ში ვხედავთ, როგორ აკავშირებს Observer (A) საკუთარ თავს Subject-ს (B) — „ჩვეულებრივი კონტროლი“. შემდეგ B ურეკავს თითოეულ A-ს და ეუბნება, რომ რამე შეიცვალა. მესამეზე Observer (A) ისევ „ჩვეულებრივ კონტროლში“ ეკითხება B-ს კონკრეტულ ინფორმაციას.  
მხოლოდ მეორე ნაბიჯი — როცა B ურეკავს A-ს — არის „ინვერსია კონტროლისა“. ეს იმიტომ ხდება, რომ Observer (A) არაა აქტიური, სანამ Subject (B)-ს მნიშვნელოვანი რაღაც არ დაემართება და B თვითონ არ დაურეკავს A-ს.

---

ვიკიპედიის მაგალითი ინვერსია კონტროლისას:  
ვებ აპლიკაცია რეგისტრირებს endpoints-ებს ვებ ფრეიმვორკში და შემდეგ კონტროლს გადასცემს ფრეიმვორკს. მაგალითად, ASP.NET Core აპლიკაციის მაგალითი:

csharp


`var builder = WebApplication.CreateBuilder(args); 
var app = builder.Build(); 
app.MapGet("/", () => "Hello World!");
app.Run();`

---

არ შეურიოთ ინვერსია კონტროლის დეპენდენსი ინჯექშენს ან დეპენდენსი ლუკაპს ისინი არათანაბარია.  
დეპენდენსი ინჯექშენი და დეპენდენსი ლუკაპი ამბობენ, როგორ გაიგებს ელემენტი A ელემენტი B-ს ვინაობას, ჩვეულებრივ მესამე ელემენტის C საშუალებით.  
A ეძახის B-ს ან უგზავნის შეტყობინებას ჩვეულებრივი წესით და A აკონტროლებს ზარის დროს.

ინვერსია კონტროლი კი განსაზღვრავს, ვინ აკონტროლებს ურთიერთობის დროს — თუ A აკონტროლებს, ეს არის „ჩვეულებრივი კონტროლი“, თუ B აკონტროლებს, ეს არის „ინვერსია კონტროლისა“.  
ინვერსია კონტროლში არ არის ელემენტი C.  
A-ს B-სთან რეგისტრაციის სხვადასხვა გზა შეუძლია: მკაცრად დაწერილი, დეპენდენსი ინჯექშენი, დეპენდენსი ლუკაპი ან ინჯექშენის ფრეიმვორკი.


## რთმანეთთან დაკავშირება

მე მიგვაჩნია, რომ გამოსადეგია სხვადასხვა საკითხების ჩამოყალიბება ცხრილებად, რომლებსაც თითოეული პატერნი ეხმიანება. ზოგი compile-დროის (კომპილაციის დროის), ზოგი კი run-time (შესრულების დროის) თემაა. ქვემოთ წარმოდგენილია ცხრილები:

- "დეპენდენსი" (დამოკიდებულება) დეპენდენსი ინვერსია პრინციპში ნიშნავს compile-დროის დამოკიდებულებას.
    
- დანარჩენები run-დროის საკითხებია.
    
- Configurable Receiver მოიცავს ორივეს — compile-დროისა და run-დროის.



| საკითხი                                                          | Dependency Injection                           | Dependency Lookup                              | Configurable Receiver                          | Inversion of Control                                         |
| ---------------------------------------------------------------- | ---------------------------------------------- | ---------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| არის თუ არა მესამე ელემენტი C, რომელიც A-ს აწყნარებს B-ს შესახებ | უნდა იყოს C                                    | უნდა იყოს C                                    | უნდა იყოს C                                    | არ არის საჭირო C                                             |
| ვინ ურეკავს ვის და როგორ                                         | A ურეკავს B-ს, როცა საჭიროა (B არ ურეკავს A-ს) | A ურეკავს B-ს, როცა საჭიროა (B არ ურეკავს A-ს) | A ურეკავს B-ს, როცა საჭიროა (B არ ურეკავს A-ს) | B ურეკავს A-ს, როცა საჭიროა (ეს არის "ინვერსია კონტროლისა")  |
| შეიძლება A-სა და B-ს ერთმანეთის ცოდნა აუცილებელი იყოს            | A უნდა იცოდეს B                                | A უნდა იცოდეს B                                | A უნდა იცოდეს B                                | A და B ერთმანეთის უნდა იცოდნენ (ორ-გვერდიანი დამოკიდებულება) |

### მოკლედ:

- **Dependency Inversion Principle** არის compile-დროის რეკომენდაცია, თუ როგორ დავაგეგმოთ კოდი ისე, რომ receivers-ი შევძლოთ შეცვალოთ run-დროის განმავლობაში, sender-ის რექომპილირების გარეშე:
    
    - კოდში sender უნდა იყოს დამოკიდებული ინტერფეისზე, რომელიც იმპლემენტირებულია receiver-ების მიერ.
        
- **Dependency Injection** ამბობს, როგორ შეიტყობს sender, რომელი receiver გამოიყენოს run-დროისას:
    
    - configurator ეუბნება sender-ს, რომელი receiver გამოიყენოს.
        
    - როგორ მუშაობენ შემდგომ ისინი — პატერნის ფარგლებს გარეთ.
        
- **Dependency Lookup** ამბობს, როგორ შეიტყობს sender, რომელი receiver გამოიყენოს run-დროისას:
    
    - sender სვამს კითხვას configurator-ს, რომელი receiver გამოიყენოს.
        
    - შემდგომი ინტერაქცია — პატერნის ფარგლებს გარეთ.
        
- **Configurable Receiver** მოიცავს compile-დროის და run-დროის საკითხებს:
    
    - compile-დროისას sender ინარჩუნებს required interface-ს, რომელსაც ყველა receiver უნდა იმპლემენტირებდეს (Dependency Inversion Principle).
        
    - run-დროისას sender ან სთხოვს ან კონფიგურატორი ეუბნება, რომელი receiver გამოიყენოს (Dependency Injection ან Dependency Lookup).
        
    - შემდგომი ურთიერთქმედება — პატერნის ფარგლებს გარეთ.
        
- **Inversion of Control** ეხება იმას, ვინ აკონტროლებს ურთიერთქმედების დროს:
    
    - ელემენტი A ჩვეულებრივად ურეკავს ელემენტ B-ს callback-ის მისამართის დასაყენებლად.
        
    - გარკვეულ მომენტში ელემენტი B ურეკავს A-ს (ეს არის „ინვერსია კონტროლისა“ ზარი), რომ რამე უთხრას ან კითხვა დაუსვას.
        
    - A-სა და B-ს ერთმანეთთან დაკავშირების გზა პატერნის გარეთ არის.


შემდეგი [[ფინალური აზრები პატერნის წერისა და სახელდების შესახებ]]