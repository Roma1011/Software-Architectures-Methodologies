#### Adapter

დიზაინის პატერნების წიგნში აღწერილია ზოგადი Adapter პატერნი: _"გადაიყვანე კლასის ინტერფეისი ისეთ ინტერფეისად, როგორსაც კლიენტები ელიან."_  
Ports & Adapters პატერნი წარმოადგენს Adapter პატერნის კონკრეტულ გამოყენებას.

#### Model-View-Controller (MVC)

MVC პატერნი ჯერ კიდევ 1974 წელს Smalltalk პროექტში დაინერგა. მას შემდეგ მას მრავალი ვარიანტი გამოუჩნდა, მაგალითად: **Model-Interactor** და **Model-View-Presenter**.  
მათში განხორციელებულია Ports & Adapters იდეა **მხოლოდ პრაიმარული პორტებისთვის**, და არა სეკუნდარულისთვის.

#### Mock Objects და Loopback

> _"Mock-ობიექტი არის „ორმაგი აგენტი“, რომელიც გამოიყენება სხვა ობიექტების ქცევის შესამოწმებლად. პირველ რიგში, ის წარმოადგენს იმიტირებულ იმპლემენტაციას ინტერფეისის ან კლასის, რომელიც რეალური იმპლემენტაციის გარეგნულ ქცევას იმეორებს. მეორე მხრივ, ის აკვირდება სხვა ობიექტების ქცევას და ადარებს მათ წინასწარ დადგენილ მოლოდინებს. თუ უთანხმოება წარმოიშვება, mock-ობიექტს შეუძლია შეაჩეროს ტესტი და გამოაქვეყნოს უარყოფა."_ — [MockObjects.com](http://MockObjects.com)

Mock-ობიექტები მათი სრული ფილოსოფიით აპლიკაციის შიდა ნაწილებშიც გამოიყენება და არა მხოლოდ გარე ინტერფეისებთან. მათი ძირითადი მიზანია **ინდივიდუალური კლასებისა და ობიექტების** მიერ პროტოკოლის დაცვა.  
ეს სტატია სესხულობს ტერმინს _mock_ როგორც საუკეთესო მოკლე აღწერას იმიტირებული (ინ-მემორი) სეკუნდარული აქტორისთვის.

**Loopback** პატერნი წარმოადგენს გამოკვეთილ პატერნს შიდა იმიტაციის შექმნისთვის გარე მოწყობილობის ჩანაცვლების მიზნით.

#### Pedestals

Barry Rubel-ის სტატიაში _"Patterns for Generating a Layered Architecture"_ აღწერილია პატერნი სახელად **Pedestal**, რომელიც მიზნად ისახავს სიმეტრიის ღერძის შექმნას საკონტროლო პროგრამებში — ეს ძალიან წააგავს Ports & Adapters იდეას.  
Pedestal პატერნში სისტემაში თითოეულ აპარატურულ მოწყობილობას შესაბამისი ობიექტი აქვს და ისინი ერთმანეთს აკავშირებს კონტროლის ფენაში.  
იგი შეიძლება გამოიყენოს Hexagonal Architecture-ის ორივე მხარეს აღსაწერად, თუმცა არ აკეთებს აქცენტს ადაპტერებს შორის მსგავსებაზე. გარდა ამისა, ის აგებულია მექანიკური კონტროლის გარემოსთვის და რთულად გადმოსატანია IT-აპლიკაციების სამყაროში.

#### Checks

Ward Cunningham-ის პატერნი, რომელიც ეხება მომხმარებლის შეყვანილი მონაცემების ვალიდაციას და შეცდომების დამუშავებას  განსაკუთრებით გამოსადეგია შიდა ჰექსაგონის საზღვრების გადაკვეთაზე.

#### Dependency Inversion, Dependency Injection და Spring

Bob Martin-ის **Dependency Inversion Principle** აცხადებს:

> _„მაღალი დონის მოდულებმა არ უნდა იყვნენ დამოკიდებული დაბალი დონის მოდულებზე. ორივე უნდა იყოს დამოკიდებული აბსტრაქციებზე. აბსტრაქციები არ უნდა იყვნენ დამოკიდებული დეტალებზე. დეტალები უნდა იყვნენ დამოკიდებული აბსტრაქციებზე.“_

Martin Fowler-ის **Dependency Injection** პატერნი გვაწვდის ამ პრინციპის იმპლემენტაციის გზებს.  
მათ საფუძველზე იქმნება ჩანაცვლებადი ადაპტერები სეკუნდარული აქტორებისთვის. ეს შესაძლებელია კოდის პირდაპირ ჩაწერით (როგორც ამ სტატიაში ნაჩვენებია) ან კონფიგურაციის ფაილების საშუალებით, რომლებიც Spring-ის მსგავს ფრეიმვორქს გადააქცევს კოდად.

---

### მადლობა

მადლობა Gyan Sharma-ს Intermountain Health Care-დან, სტატიის მაგალითის კოდისთვის.  
მადლობა Rebecca Wirfs-Brock-ს მისი წიგნისთვის _Object Design_, რომელმაც დიზაინის პატერნების წიგნის _Adapter_ პატერნთან ერთად დამეხმარა ჰექსაგონის იდეის გააზრებაში.  
და მადლობა იმ ხალხს, ვინც Ward Cunningham-ის ვიკიზე წლების განმავლობაში ამ არქიტექტურის კომენტარებს ტოვებდა (განსაკუთრებით Kevin Rutherford-ს:  
[http://silkandspinach.net/blog/2004/07/hexagonal_soup.html](http://silkandspinach.net/blog/2004/07/hexagonal_soup.html)).