Ports & Adapters არქიტექტურა განსხვავდება Layered, Onion და Clean არქიტექტურებისგან ორი გზით:

- **Ports & Adapters-ს მხოლოდ ორი ფენა აქვს**: შიდა (აპლიკაცია) და გარე (ყველაფერი დანარჩენი).
    
- **Ports & Adapters მოითხოვს**, რომ გარე აქტორები ორგანიზებულნი იყვნენ ისე, რომ დაკავშირებულნი იყვნენ კონკრეტულ პორტებთან.
    

მაგრამ მოდი, ჯერ ტრადიციულ ფენოვან არქიტექტურებს დავაკვირდეთ. ფენოვან არქიტექტურაში კოდი იყოფა ინტერესის სფეროებით და აწყობილია “ზემოდან ქვევით” პრინციპით, ისე, რომ მაღალ დონეზე მყოფ ელემენტებს აქვთ გამოძახება ან დამოკიდებულება დაბალ დონეზე მყოფებზე. უფრო აბსტრაქტული ელემენტები, როგორიცაა პოლიტიკის ობიექტები, მოთავსებულია ზედა ფენაში, მაშინ როდესაც აპარატურა და დრაივერები – ქვედაში. პოლიტიკის ელემენტები დამოკიდებულნი არიან დრაივერებსა და აპარატურაზე.

**Ports & Adapters**, **Onion** და **Clean** არქიტექტურები ყველა ათავსებს აპლიკაციას და დომენს UI-სა და ინფრასტრუქტურაზე ქვემოთ, როგორც ეს ნაჩვენებია ![[Pasted image 20250708170602.png]]
ნახატი Ports & Adapters მხოლოდ ორ ფენას განსაზღვრავს: შიდა და გარე.


ეს არქიტექტურები შებრუნებულად გამოიყურება ტრადიციულ ფენოვან არქიტექტურებთან შედარებით.


აპლიკაციის შიდა ნაწილი, თავისი პოლიტიკის ელემენტებით, ქვედა ფენაშია. დანარჩენი ყველაფერი ზემოთ არის მოთავსებული და ქვემოთ მიუთითებს, იმიტომ რომ აპლიკაციას **არ უნდა ჰქონდეს compile-time დამოკიდებულება სხვა რამეზე**.

ზედა ფენის შიგნით, ანუ “გარე” ნაწილში, შეგიძლიათ გქონდეთ რამდენი ფენაც გსურთ – ეს გადაწყვეტილებები არ ეკუთვნის Ports & Adapters არქიტექტურის კომპეტენციას და თქვენი პირადი არჩევანია.

დამოკიდებულებებისა და შესრულების თანმიმდევრობა 3-ფენიან არქიტექტურაში და Ports & Adapters-ში.
მარჯვნივ ვხედავთ Ports & Adapters არქიტექტურას. ისევე როგორც ზედა ნახატში ინვოისინგის სისტემა ქვედა ფენაშია, ხოლო GUI-ს და ბაზას (ან მის ადაპტერს) აქვთ **compile-time დამოკიდებულება** ინვოისინგის სისტემაზე.

გაკვირვებას იწვევს ის, რომ **შესრულების თანმიმდევრობა განსხვავებულია** დამოკიდებულებების მიმართულებისგან **Driven** მხარეს. ინვოისინგის სისტემა კვლავ აგზავნის გამოძახებებს ბაზაში, მაგრამ ბაზას (ან მის ადაპტერს) აქვს compile-time დამოკიდებულება ინვოისინგის სისტემაზე. ეს განსხვავდება ფენოვანი არქიტექტურისგან.
![[Pasted image 20250708170805.png]]
ნახატი აჩვენებენ, რატომ გამოიყურება Ports & Adapters უცნაურად, როდესაც მიჩვეული ხარ ფენოვან არქიტექტურას.
ინვოისინგის სისტემას GUI-თი და ბაზით. მარცხნივ ვხედავთ ჩვეულ 3-ფენიან არქიტექტურას, სადაც დამოკიდებულებები და შესრულება ქვემოთ მიუთითებს.



აჩვენებს ადაპტერებს. შეძენილ ბაზას აქვს თავისი გამოქვეყნებული ინტერფეისი, რომელიც არ ემთხვევა სისტემის დომენურ ინტერფეისს. ამიტომ საჭიროა ადაპტერი. ჩვეულებრივ, ეს ადაპტერი განიხილება როგორც სისტემის ნაწილი, რომელსაც ვქმნით.
![[Pasted image 20250708171038.png]]
**მარცხენა მხარეს**, როგორც compile-time დამოკიდებულებები, ისე შესრულების ნაკადი მიდის ბიზნეს ლოგიკიდან ადაპტერისკენ და იქიდან ბაზისკენ.

**მარჯვენა მხარეს** ნაჩვენებია დამოკიდებულებები და შესრულება Ports & Adapters არქიტექტურაში. შენიშნე, რომ ადაპტერი **სისტემის გარეთაა**.

- სისტემა აქვეყნებს მის მიერ საჭიროებულ driven პორტის სპეციფიკაციას (ნახატში კაუჭი, რომელიც ზემოთ იშვერს);
    
- ადაპტერს აქვს compile-time დამოკიდებულება ამ ინტერფეისზე და ის მას **აიმპლემენტირებს** (ბურთი კაუჭში ჯდება);
    
- ადაპტერს ასევე აქვს compile-time დამოკიდებულება და იყენებს ბაზის მიერ განსაზღვრულ ინტერფეისს.
    

შენიშნე, რომ **არც ინვოისინგის სისტემა და არც ბაზა არ არიან ერთმანეთზე დამოკიდებულნი** – ისინი დამოუკიდებლები არიან. ადაპტერი ორივეზეა დამოკიდებული. შესრულების ნაკადი მიდის ინვოისინგის სისტემიდან ადაპტერისკენ და იქიდან ბაზისკენ (და უკან).
ადაპტერის გატანა სისტემის გარეთ და მისი დამოკიდებულება როგორც სისტემაზე, ისე ბაზაზე.