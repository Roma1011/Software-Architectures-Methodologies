Ports & Adapters არქიტექტურა განსხვავდება Layered, Onion და Clean არქიტექტურებისგან ორი გზით:

- **Ports & Adapters-ს მხოლოდ ორი ფენა აქვს**: შიდა (აპლიკაცია) და გარე (ყველაფერი დანარჩენი).
    
- **Ports & Adapters მოითხოვს**, რომ გარე აქტორები ორგანიზებულნი იყვნენ ისე, რომ დაკავშირებულნი იყვნენ კონკრეტულ პორტებთან.
    

ტრადიციულ ფენოვან არქიტექტურებს დავაკვირდეთ. ფენოვან არქიტექტურაში კოდი იყოფა ინტერესის სფეროებით და აწყობილია “ზემოდან ქვევით” პრინციპით, ისე, რომ მაღალ დონეზე მყოფ ელემენტებს აქვთ გამოძახება ან დამოკიდებულება დაბალ დონეზე მყოფებზე. უფრო აბსტრაქტული ელემენტები, როგორიცაა პოლიტიკის ობიექტები, მოთავსებულია ზედა ფენაში, მაშინ როდესაც აპარატურა და დრაივერები ქვედაში. პოლიტიკის ელემენტები დამოკიდებულნი არიან დრაივერებსა და აპარატურაზე.

**Ports & Adapters**, **Onion** და **Clean** არქიტექტურები ყველა ათავსებს აპლიკაციას და დომენს UI-სა და ინფრასტრუქტურაზე ქვემოთ, როგორც ეს ნაჩვენებია ![[Pasted image 20250708170602.png]]
ნახატი Ports & Adapters მხოლოდ ორ ფენას განსაზღვრავს: შიდა და გარე.


ეს არქიტექტურები შებრუნებულად გამოიყურება ტრადიციულ ფენოვან არქიტექტურებთან შედარებით.


აპლიკაციის შიდა ნაწილი, თავისი პოლიტიკის ელემენტებით, ქვედა ფენაშია. დანარჩენი ყველაფერი ზემოთ არის მოთავსებული და ქვემოთ მიუთითებს, იმიტომ რომ აპლიკაციას **არ უნდა ჰქონდეს compile-time დამოკიდებულება სხვა რამეზე**.

ზედა ფენის შიგნით, ანუ “გარე” ნაწილში, შეგიძლიათ გქონდეთ რამდენი ფენაც გსურთ – ეს გადაწყვეტილებები არ ეკუთვნის Ports & Adapters არქიტექტურის კომპეტენციას და თქვენი პირადი არჩევანია.

დამოკიდებულებებისა და შესრულების თანმიმდევრობა 3-ფენიან არქიტექტურაში და Ports & Adapters-ში.
მარჯვნივ ვხედავთ Ports & Adapters არქიტექტურას. ისევე როგორც ზედა ნახატში ინვოისინგის სისტემა ქვედა ფენაშია, ხოლო GUI-ს და ბაზას (ან მის ადაპტერს) აქვთ **compile-time დამოკიდებულება** ინვოისინგის სისტემაზე.

გაკვირვებას იწვევს ის, რომ **შესრულების თანმიმდევრობა განსხვავებულია** დამოკიდებულებების მიმართულებისგან **Driven** მხარეს. ინვოისინგის სისტემა კვლავ აგზავნის გამოძახებებს ბაზაში, მაგრამ ბაზას (ან მის ადაპტერს) აქვს compile-time დამოკიდებულება ინვოისინგის სისტემაზე. ეს განსხვავდება ფენოვანი არქიტექტურისგან.
![[Pasted image 20250708170805.png]]
ნახატი აჩვენებენ, რატომ გამოიყურება Ports & Adapters უცნაურად, როდესაც მიჩვეული ხარ ფენოვან არქიტექტურას.
ინვოისინგის სისტემას GUI-თი და ბაზით. მარცხნივ ვხედავთ ჩვეულ 3-ფენიან არქიტექტურას, სადაც დამოკიდებულებები და შესრულება ქვემოთ მიუთითებს.



აჩვენებს ადაპტერებს. შეძენილ ბაზას აქვს თავისი გამოქვეყნებული ინტერფეისი, რომელიც არ ემთხვევა სისტემის დომენურ ინტერფეისს. ამიტომ საჭიროა ადაპტერი. ჩვეულებრივ, ეს ადაპტერი განიხილება როგორც სისტემის ნაწილი, რომელსაც ვქმნით.
![[Pasted image 20250708171038.png]]
**მარცხენა მხარეს**, როგორც compile-time დამოკიდებულებები, ისე შესრულების ნაკადი მიდის ბიზნეს ლოგიკიდან ადაპტერისკენ და იქიდან ბაზისკენ.

**მარჯვენა მხარეს** ნაჩვენებია დამოკიდებულებები და შესრულება Ports & Adapters არქიტექტურაში. შენიშნე, რომ ადაპტერი **სისტემის გარეთაა**.

- სისტემა აქვეყნებს მის მიერ საჭიროებულ driven პორტის სპეციფიკაციას (ნახატში კაუჭი, რომელიც ზემოთ იშვერს);
    
- ადაპტერს აქვს compile-time დამოკიდებულება ამ ინტერფეისზე და ის მას **აიმპლემენტირებს** (ბურთი კაუჭში ჯდება);
    
- ადაპტერს ასევე აქვს compile-time დამოკიდებულება და იყენებს ბაზის მიერ განსაზღვრულ ინტერფეისს.
    

შენიშნე, რომ **არც ინვოისინგის სისტემა და არც ბაზა არ არიან ერთმანეთზე დამოკიდებულნი** – ისინი დამოუკიდებლები არიან. ადაპტერი ორივეზეა დამოკიდებული. შესრულების ნაკადი მიდის ინვოისინგის სისტემიდან ადაპტერისკენ და იქიდან ბაზისკენ (და უკან).
ადაპტერის გატანა სისტემის გარეთ და მისი დამოკიდებულება როგორც სისტემაზე, ისე ბაზაზე.


**ჯეიმს გრენინგის ჩაშენებული (Embedded) IoT**

პარალელურ განვითარებაში, ჯეიმს გრენინგმა (Agile Manifesto-ს ერთ-ერთმა ავტორმა) ზუსტად იგივე არქიტექტურა შექმნა, რაც არის **Ports & Adapters**, თუმცა ის იყენებდა აპარატურასთან (hardware) დაკავშირებულ სისტემებზე. ჩვენ აღმოვაჩინეთ, რომ ორივე დიზაინი იდენტურია — უბრალოდ სხვადასხვა ტერმინებს ვიყენებთ. ჩემთვის განსაკუთრებით საინტერესო იყო, რომ ის **Driven Adapter**-ებს **“სერვისის აბსტრაქციის ფენას” (Service Abstraction Layer)** უწოდებდა — რაც, მართლაც, შესაფერისად ჟღერს.

**ნახატი 5.5. გრენინგის IoT სისტემა.**

მისმა სადემონსტრაციო დიაგრამამ ცოტა დამაბნა, რადგან შეტყობინებების რიგზე (`message queue`) `get` გამოძახება **Driven Port**-ად არის ნაჩვენები! ეს Initially მაწუხებდა, სანამ არ მითხრა, რომ შეტყობინებების რიგი პოულდება: აპლიკაცია ყოველ წამში აგზავნის `get` მოთხოვნას. ასე რომ, პორტები სწორად არის განსაზღვრული.

იხილეთ მისი სრული ახსნა და Python კოდი მომავალი წიგნის **Clean Code: A Handbook of Agile Software Craftsmanship, მე-2 გამოცემა (2025)** მეთორმეტე თავში.




**Onion და Clean**

**Onion** და **Clean** არქიტექტურები იმავე დამოკიდებულების (dependency) სტრუქტურას იყენებენ, რაც აქვს **Ports & Adapters**-ს. განსხვავება ორია:

1. ისინი **პორტების განსაზღვრას არ ითხოვენ**,
    
2. და ითხოვენ **დამატებით შრეებს**, რასაც **Ports & Adapters** არ მოითხოვს.
    

![[Pasted image 20250709205310.png]]
https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html


![[Pasted image 20250709205326.png]]
https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/



როცა უკვე გექნებათ განხორციელებული **Ports & Adapters**, თავისუფლად შეგიძლიათ დაამატოთ **Clean**-ისა და **Onion**-ის შრეები — ან არა. ეს გადაწყვეტილებები **Ports & Adapters**-ის ფარგლებს გარეთ არის და მხოლოდ თქვენზეა დამოკიდებული.

თუ ამ დროს თავს დატვირთულად გრძნობთ ამდენი ნახატით, ნუ იდარდებთ. გახსოვდეთ დავით ადამოს (David Adamo Jr) სიბრძნე:  
**„კოდი ნახატებზე უფრო მარტივია.“**

დაიმახსოვრეთ: **Ports & Adapters**-ში თავისუფალი ხართ აპლიკაციის შიდა ნაწილი ისე მოაწყოთ, როგორც გსურთ — და ასევე ის, რაც გარეთაა.

მხოლოდ ერთი რამ გააკეთეთ: **დასვით პორტები.**  
ოჰ, და ტესტებიც დაწერეთ.



## **Layered-დან Ports & Adapters-ზე გადასვლა**  

**ოლივერ ციჰლერმა** გამოაქვეყნა შესანიშნავი სტატია Substack-ზე:  
🔗 [https://codearfy.substack.com/p/from-layered-to-hexagonal-architecture](https://codearfy.substack.com/p/from-layered-to-hexagonal-architecture)  
**"Layered-დან Hexagonal არქიტექტურაზე 2 ეტაპში"**, სადაც ეს პროცესი ნათლად არის აღწერილი.

აქ მოყვანილია მისი სქემები. თუ არ არის ნათელი, როგორ უნდა გავიგოთ ისინი, სტატია წაიკითხეთ — იქ ყველაფერი დეტალურად არის ახსნილი.

---

**ნაბიჯი 0:** თქვენი საწყისი წერტილი
![[Pasted image 20250709205754.png]]
**ნაბიჯი 1:** დამოკიდებულებების ინვერსია
![[Pasted image 20250709205821.png]]
**ნაბიჯი 2:** დარწმუნდით, რომ პორტები აპლიკაციის შიგნით არის განსაზღვრული.  
**მზადაა.** 
![[Pasted image 20250709205844.png]]